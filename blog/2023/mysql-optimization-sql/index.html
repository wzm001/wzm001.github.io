<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>MySQL 性能优化之 EXPLAIN 关键字 | Jimmy Wu</title> <meta name="author" content="Jimmy Wu"> <meta name="description" content="MySQL 的优化操作"> <meta name="keywords" content="Java, 后端, Software Developer"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/icon.png#%20the%20emoji%20used%20as%20the%20favicon%20(alternatively,%20provide%20image%20name%20in%20/assets/img/)"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://wzm001.github.io//blog/2023/mysql-optimization-sql/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "MySQL 性能优化之 EXPLAIN 关键字",
      "description": "MySQL 的优化操作",
      "published": "March 17, 2023",
      "authors": [
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Jimmy Wu</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">关于我</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">博客<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">项目</a> </li> <li class="nav-item "> <a class="nav-link" href="/assets/pdf/cv.pdf">简历</a> </li> <li class="nav-item "> <a class="nav-link" href="/assets/pdf/ecv.pdf">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>MySQL 性能优化之 EXPLAIN 关键字</h1> <p>MySQL 的优化操作</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#explain-%E5%85%B3%E9%94%AE%E5%AD%97">EXPLAIN 关键字</a></div> <ul> <li><a href="#"></a></li> </ul> <div><a href="#%E4%BC%98%E5%8C%96%E5%AE%9E%E4%BE%8B">优化实例</a></div> <ul> <li><a href="#"></a></li> </ul> </nav> </d-contents> <p>本系列分为多个主题，主要参考学习了 MySQL 参考手册中关于<a href="https://dev.mysql.com/doc/refman/8.0/en/optimization.html" rel="external nofollow noopener" target="_blank">优化</a> 的相关章节，重点整理工作中经常遇到的内容。</p> <h1 id="explain-关键字">EXPLAIN 关键字</h1> <p><code class="language-plaintext highlighter-rouge">EXPLAIN</code> 关键字显示了 MySQL 的执行计划，可以用来分析 MySQL 优化器是如何选择合适的方式执行查询。<code class="language-plaintext highlighter-rouge">EXPLAIN</code> 可以和 <code class="language-plaintext highlighter-rouge">SELECT</code>、<code class="language-plaintext highlighter-rouge">DELETE</code>、<code class="language-plaintext highlighter-rouge">INSERT</code>、<code class="language-plaintext highlighter-rouge">UPDATE</code> 和 <code class="language-plaintext highlighter-rouge">REPLACE</code> 语句组合使用。</p> <p><code class="language-plaintext highlighter-rouge">EXPLAIN</code> 为 <code class="language-plaintext highlighter-rouge">SELECT</code> 语句中使用的每一个表返回一行信息，并且按照 MySQL 处理语句时读取它们的顺序列出。也就是说 MySQL 将会从第一行展示的表中读取信息，然后再在第二行展示的表中找到匹配的行，然后是第三行……依次类推。当所有的表都处理完后，MySQL 将选择的列输出。然后在进行下一次操作，直到找到所有匹配的结果。</p> <h2 id="explain-的输出列">EXPLAIN 的输出列</h2> <p>下表列出了 <code class="language-plaintext highlighter-rouge">EXPLAIN</code> 每一行输出的列信息：</p> <table> <thead> <tr> <th>Column</th> <th>JSON Name</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td>id</td> <td>select_id</td> <td> <code class="language-plaintext highlighter-rouge">SELECT</code> 的标识符，这是查询中 <code class="language-plaintext highlighter-rouge">SELECT</code> 的序号，如果该行属于其他行 union 的结果，则该值为 null，此时 <code class="language-plaintext highlighter-rouge">table</code> 列显示的名称类似于 <code class="language-plaintext highlighter-rouge">&lt;unionM,N&gt;</code>，表示该行来自 id 为 M 和 N 的查询的并集</td> </tr> <tr> <td>select_type</td> <td>(None)</td> <td> <code class="language-plaintext highlighter-rouge">SELECT</code> 的类型。具体类型见下面的表格</td> </tr> <tr> <td>table</td> <td>table_name</td> <td>输出行对应的表名，可以是下列值：<br> &lt;li&gt;&lt;unionM,N&gt;: 该行来自 id 为 M 和 N 的查询结果的并集&lt;/li&gt;&lt;li&gt;&lt;derivedN&gt;: 该行来自 id 为 N 的查询派生表，例如可能来自 FROM 子句中的子查询&lt;/li&gt;&lt;li&gt;&lt;subqueryN&gt;: 该行来自 id 为 N 的行的具体化子查询结果&lt;/li&gt;</td> </tr> <tr> <td>partitions</td> <td>partitions</td> <td>匹配的分区，非分区表的值为 NULL</td> </tr> <tr> <td>type</td> <td>access_type</td> <td>访问数据的类型。具体见下面的表格</td> </tr> <tr> <td>possible_keys</td> <td>possible_keys</td> <td>可供选择的索引，如果此列为 NULL，表示查询没有可用使用的索引，这种情况下需要检查 WHERE 条件是否有适用的索引</td> </tr> <tr> <td>key</td> <td>key</td> <td>实际选择的索引，这里列出的值可能不包含在 <code class="language-plaintext highlighter-rouge">possible_keys</code> 列中，这意味着 WHERE 条件没有用到索引，但查询的列是从索引中获取的，也就是索引覆盖的场景。<br>如果要强制 MySQL 使用或忽略 <code class="language-plaintext highlighter-rouge">possible_keys</code> 列出的索引，可以使用 <code class="language-plaintext highlighter-rouge">FORCE INDEX</code>、<code class="language-plaintext highlighter-rouge">USE INDEX</code>或<code class="language-plaintext highlighter-rouge">IGNORE INDEX</code> </td> </tr> <tr> <td>key_len</td> <td>key_len</td> <td>索引使用的字节数</td> </tr> <tr> <td>ref</td> <td>ref</td> <td>显示将哪些列或常量与<code class="language-plaintext highlighter-rouge">key</code>列中的索引值进行比较以从表中选择行。如果值为 <code class="language-plaintext highlighter-rouge">func</code>，则使用的值是某个函数的结果。可以在 <code class="language-plaintext highlighter-rouge">EXPLAIN</code> 之后使用 <code class="language-plaintext highlighter-rouge">SHOW WARNINGS</code> 查看扩展输出。该函数实际可能是一个运算符，例如算术运算符</td> </tr> <tr> <td>rows</td> <td>rows</td> <td>估计要检查的行，对于 InnoDB 来说，这个值是估计的，可能并不准确</td> </tr> <tr> <td>filtered</td> <td>filtered</td> <td>按表的查询条件过滤的行百分比，最大为 100，表示没有发生行过滤</td> </tr> <tr> <td>Extra</td> <td>(None)</td> <td>附加信息</td> </tr> </tbody> </table> <h3 id="select_type-列对应的值"> <code class="language-plaintext highlighter-rouge">select_type</code> 列对应的值</h3> <table> <thead> <tr> <th> <code class="language-plaintext highlighter-rouge">select_type</code> Value</th> <th>JSON Name</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td>SIMPLE</td> <td>(None)</td> <td>简单的 <code class="language-plaintext highlighter-rouge">SELECT</code>，不使用 <code class="language-plaintext highlighter-rouge">UNION</code> 或子查询</td> </tr> <tr> <td>PRIMARY</td> <td>(None)</td> <td>最外层的 <code class="language-plaintext highlighter-rouge">SELECT</code> </td> </tr> <tr> <td>UNION</td> <td>(None)</td> <td>联表查询中的第二个或之后的 <code class="language-plaintext highlighter-rouge">SELECT</code> 语句</td> </tr> <tr> <td>DEPENDENT UNION</td> <td>dependent(true)</td> <td>联表查询中的第二个或之后的 <code class="language-plaintext highlighter-rouge">SELECT</code> 语句，依赖于外部查询</td> </tr> <tr> <td>UNION RESULT</td> <td>union_result</td> <td>联表查询的结果</td> </tr> <tr> <td>SUBQUERY</td> <td>(None)</td> <td>子查询中的第一个 <code class="language-plaintext highlighter-rouge">SELECT</code> </td> </tr> <tr> <td>DEPENDENT SUBQUERY</td> <td>dependent(true)</td> <td>子查询中的第一个 <code class="language-plaintext highlighter-rouge">SELECT</code> ，依赖于外部查询</td> </tr> <tr> <td>DERIVED</td> <td>(None)</td> <td>派生表</td> </tr> <tr> <td>DEPENDENT DERIVED</td> <td>dependent(true)</td> <td>派生表，依赖于另一张表</td> </tr> <tr> <td>MATERIALIZED</td> <td>materialized_from_subquery</td> <td>物化的子查询？</td> </tr> <tr> <td>UNCACHEABLE SUBQUERY</td> <td>cacheable(false)</td> <td>无法缓存的子查询，外部查询的每一行都需要重新执行</td> </tr> <tr> <td>UNCACHEABLE UNION</td> <td>cacheable(false)</td> <td>不可缓存的子查询中的第二个或之后的查询</td> </tr> <tr> <td>DELETE / UPDATE / REPLACE</td> <td> </td> <td>非 <code class="language-plaintext highlighter-rouge">SELECT</code> 类型的语句，展示的是语句类型</td> </tr> </tbody> </table> <h3 id="type-列对应的值"> <code class="language-plaintext highlighter-rouge">type</code> 列对应的值</h3> <h4 id="system">system</h4> <p>该表只有一行（=系统表）。这是 const 连接类型的一个特例。</p> <h4 id="const">const</h4> <p>该表最多有一个匹配行，在查询开始时读取。因为只有一行，优化器可以将这一行的值视为常量。const 非常快，因为只需要查询一次。 当主键索引或唯一索引与常量比较时，将使用 const。例如下列查询：</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">tb1_name</span> <span class="k">where</span> <span class="n">primary_key</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">tb1_name</span> <span class="k">where</span> <span class="n">primary_key_part1</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">and</span> <span class="n">primary_key_part2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div></div> <h4 id="eq_ref">eq_ref</h4> <p>索引查找。对于先前表中的每个组合，都从该表中读取一行。这是除了 <code class="language-plaintext highlighter-rouge">system</code> 和 <code class="language-plaintext highlighter-rouge">const</code> 之外最好的连接类型。当连接使用索引的所有部分并且索引是 <code class="language-plaintext highlighter-rouge">PRIMARY KEY</code> 或 <code class="language-plaintext highlighter-rouge">UNIQUE NOT NULL</code> 类型时使用。</p> <p><code class="language-plaintext highlighter-rouge">eq_ref</code> 可用于使用 <code class="language-plaintext highlighter-rouge">=</code> 运算符进行比较的索引列。比较值可以是常量或表达式。例如：</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">ref_table</span><span class="p">,</span> <span class="n">other_table</span> 
 <span class="k">where</span> <span class="n">ref_table</span><span class="p">.</span><span class="n">key_column</span> <span class="o">=</span> <span class="n">other_table</span><span class="p">.</span><span class="k">column</span><span class="p">;</span>

<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">ref_table</span><span class="p">,</span> <span class="n">other_table</span>
 <span class="k">where</span> <span class="n">ref_table</span><span class="p">.</span><span class="n">key_column_part1</span> <span class="o">=</span> <span class="n">other_table</span><span class="p">.</span><span class="k">column</span>
 <span class="k">and</span> <span class="n">ref_table</span><span class="p">.</span><span class="n">key_column_part2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div> <h4 id="ref">ref</h4> <p>索引查找。对于先前表中行的每个组合，从该表中读取具有匹配索引值的所有行。如果连接仅使用键的最左前缀，或者如果键不是 <code class="language-plaintext highlighter-rouge">PRIMARY KEY</code> 或 <code class="language-plaintext highlighter-rouge">UNIQUE</code> 索引（也就是说，如果连接不能根据键值选择耽搁行），则使用 <code class="language-plaintext highlighter-rouge">ref</code>。如果使用的键值匹配几行，这是一个很好的连接类型。例如：</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">ref_table</span> <span class="k">where</span> <span class="n">key_column</span> <span class="o">=</span> <span class="n">expr</span><span class="p">;</span>

<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">ref_table</span><span class="p">,</span> <span class="n">other_table</span>
 <span class="k">where</span> <span class="n">ref_table</span><span class="p">.</span><span class="n">key_column</span> <span class="o">=</span> <span class="n">other_table</span><span class="p">.</span><span class="k">column</span><span class="p">;</span>

<span class="n">selct</span> <span class="o">*</span> <span class="k">from</span> <span class="n">ref_table</span><span class="p">,</span> <span class="n">other_table</span>
 <span class="k">where</span> <span class="n">ref_table</span><span class="p">.</span><span class="n">key_column_part1</span> <span class="o">=</span> <span class="n">other_table</span><span class="p">.</span><span class="k">column</span>
 <span class="k">and</span> <span class="n">ref_table</span><span class="p">.</span><span class="n">key_column_part2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div> <h4 id="fulltext">fulltext</h4> <p>使用全文索引执行连接。</p> <h4 id="ref_or_null">ref_or_null</h4> <p>这种连接类型类似于 <code class="language-plaintext highlighter-rouge">ref</code>，但 MySQL 会额外搜索包含 <code class="language-plaintext highlighter-rouge">NULL</code> 的行。这种连接类型优化最常用语解析子查询，例如：</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">ref_table</span> <span class="k">where</span> <span class="n">key_column</span> <span class="o">=</span> <span class="n">expr</span> <span class="k">or</span> <span class="n">key_column</span> <span class="k">is</span> <span class="k">null</span><span class="p">;</span>
</code></pre></div></div> <h4 id="index_merge">index_merge</h4> <p>此连接类型使用了索引合并优化。在这种情况下，输出行的 <code class="language-plaintext highlighter-rouge">key</code> 列包含了使用的索引列表，<code class="language-plaintext highlighter-rouge">key_len</code> 包含使用的索引的最长键部分列表。</p> <h4 id="unique_subquery">unique_subquery</h4> <p>此类型替换 <code class="language-plaintext highlighter-rouge">eq_ref</code> 用于一下形式的某些 <code class="language-plaintext highlighter-rouge">IN</code> 查询：</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">primary_key</span> <span class="k">FROM</span> <span class="n">single_table</span> <span class="k">WHERE</span> <span class="n">some_expr</span><span class="p">)</span>
</code></pre></div></div> <p>表示子查询的结果可以通过唯一索引获取。</p> <h4 id="index_subquery">index_subquery</h4> <p>此类型类似于 <code class="language-plaintext highlighter-rouge">unique_subquery</code> ，区别是子查询使用非唯一索引。</p> <h4 id="range">range</h4> <p>仅检索给定范围内的行，使用索引来选择行。输出行的 <code class="language-plaintext highlighter-rouge">key</code> 列指示使用了哪个索引。<code class="language-plaintext highlighter-rouge">key_len</code> 包含使用过的最长键部分。对于这种类型，<code class="language-plaintext highlighter-rouge">ref</code> 列是 NULL。</p> <p>range可能用于 <code class="language-plaintext highlighter-rouge">=, &lt;&gt;, &gt;, &gt;=, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, LIKE, IN</code> 操作中。</p> <h4 id="index">index</h4> <p>此类型与下面的全表扫描 <code class="language-plaintext highlighter-rouge">ALL</code> 相同，区别是扫描了索引树。有两种情况：</p> <ul> <li>如果查询是覆盖索引，无需回表的话，<code class="language-plaintext highlighter-rouge">Extra</code> 列会显示 <code class="language-plaintext highlighter-rouge">Using index</code>，仅扫描索引通常比全表扫描更快，因为索引的大小通常小于表数据。</li> <li>如果索引无法覆盖查询，则 <code class="language-plaintext highlighter-rouge">Extra</code> 列不会显示 <code class="language-plaintext highlighter-rouge">Using index</code>。</li> </ul> <p>当查询仅使用单个索引的列时，MySQL 可以使用该连接类型。</p> <h4 id="all">all</h4> <p>全表扫描。这是性能最差的连接方式，应该尽量避免。</p> <h3 id="extra-列的额外信息说明">Extra 列的额外信息说明</h3> <p>Extra 列在不同的场景下展示的信息很多。这里只列出一些常见的信息，更详细的内容参考<a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-join-types" rel="external nofollow noopener" target="_blank">这里</a></p> <h4 id="using-filesort">Using filesort</h4> <p>MySQL 必须执行额外的数据传递，以完成结果的检索排序。而不是按照索引次序从表中读取行。这意味着查询效率低下。 MySQL 有两种文件排序算法，都可以在内存或磁盘上完成，因此出现这个信息并不意味着一定使用了磁盘排序。</p> <h4 id="using-index">Using index</h4> <p>仅使用索引树中的信息查询，不需要执行额外的查找。也就是使用了覆盖索引优化。</p> <h4 id="using-index-condition">Using index condition</h4> <p>通过访问索引元组并首先测试它们以确定是否读取完整的表。以这种方式，索引信息用于延迟（下推）读取全表，具体参考<a href="https://dev.mysql.com/doc/refman/8.0/en/index-condition-pushdown-optimization.html" rel="external nofollow noopener" target="_blank">索引下推优化</a>。</p> <h4 id="using-index-for-group-by">Using index for group-by</h4> <p>表示 MySQL 找到一个索引，可以用于检索 <code class="language-plaintext highlighter-rouge">group by</code> 或 <code class="language-plaintext highlighter-rouge">distinct</code> 查询的所有列，而无需对实际的表进行任何额外的磁盘访问。</p> <h4 id="using-temporary">Using temporary</h4> <p>为了解析查询，MySQL 需要创建一个临时表用来保存结果。如果查询包含以不同方式列出的 <code class="language-plaintext highlighter-rouge">group by</code> 和 <code class="language-plaintext highlighter-rouge">order by</code>。这意味着查询效率低下。</p> <h4 id="using-where">Using where</h4> <p>意味着 MySQL 服务器将在存储引擎检索行之后再进行过滤。</p> <h1 id="优化实例">优化实例</h1> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography><div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"wzm001/wzm001.github.io","data-repo-id":"R_kgDOG5N29g","data-category":"Announcements","data-category-id":"DIC_kwDOG5N29s4CUo0g","data-mapping":"title","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Jimmy Wu. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>