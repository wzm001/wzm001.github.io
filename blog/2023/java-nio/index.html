<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Java NIO 概念梳理 | Jimmy Wu</title> <meta name="author" content="Jimmy Wu"> <meta name="description" content="Java NIO 概念和使用"> <meta name="keywords" content="Java, 后端, Software Developer"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/icon.png#%20the%20emoji%20used%20as%20the%20favicon%20(alternatively,%20provide%20image%20name%20in%20/assets/img/)"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://wzm001.github.io//blog/2023/java-nio/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Jimmy Wu</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">关于我</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">博客<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">项目</a> </li> <li class="nav-item "> <a class="nav-link" href="/assets/pdf/cv.pdf">简历</a> </li> <li class="nav-item "> <a class="nav-link" href="/assets/pdf/ecv.pdf">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Java NIO 概念梳理</h1> <p class="post-meta">April 15, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/java"> <i class="fas fa-hashtag fa-sm"></i> Java</a>   <a href="/blog/tag/nio"> <i class="fas fa-hashtag fa-sm"></i> NIO</a>     ·   <a href="/blog/category/java"> <i class="fas fa-tag fa-sm"></i> Java</a>   <a href="/blog/category/io"> <i class="fas fa-tag fa-sm"></i> IO</a>   </p> </header> <article class="post-content"> <p>看了很多零零散散的 NIO 文章，但没有形成系统的认识。今天尝试整理一下 NIO 的相关概念。</p> <h1 id="什么是-nio">什么是 NIO</h1> <p>Java 提供的传统 IO 模型称为 BIO (阻塞 IO，Blocking IO)，而 NIO 称为“非阻塞 IO” （Non-blocking IO）。传统 IO 是面向输入/输出流（InputStream / OutputStream）的，NIO 是面向通道（Channel）的。</p> <p>在进一步介绍概念之前，我们先理解一下什么是 <em>阻塞</em> 。</p> <blockquote> <p>阻塞从概念上理解，指的是当前工作卡在某个点无法进行下去。从编程模型上讲，阻塞的对象就是线程。线程从运行态转为阻塞态，不再占用 CPU 资源，就代表该线程被阻塞。</p> </blockquote> <p>假如某线程要读取一个文件：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"/Users/tiger/test.txt"</span><span class="o">);</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">buf</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
<span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buf</span><span class="o">);</span> <span class="c1">// 此方法会阻塞线程，在数据读取完成之前，下面的代码无法执行</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">buf</span><span class="o">));</span>
</code></pre></div></div> <p>我们看到，在传统 BIO 模型下，<code class="language-plaintext highlighter-rouge">InputStream</code> 的 <code class="language-plaintext highlighter-rouge">read()</code> 方法会阻塞线程，此时 JVM 会调用操作系统读取文件，程序从用户态转为内核态，当操作系统将文件读取完成并且把数据从内核缓冲区拷贝到 JVM 的内存中后，该线程才会被唤起继续执行。大概的流程如下图：</p> <div class="jekyll-diagrams diagrams mermaid"> <svg id="mermaid-1686152183322" width="100%" xmlns="http://www.w3.org/2000/svg" height="100%" style="max-width:650px;" viewbox="-50 -10 650 347"><style>#mermaid-1686152183322 .label{font-family:trebuchet ms,verdana,arial;color:#333}#mermaid-1686152183322 .node circle,#mermaid-1686152183322 .node ellipse,#mermaid-1686152183322 .node polygon,#mermaid-1686152183322 .node rect{fill:#ececff;stroke:#9370db;stroke-width:1px}#mermaid-1686152183322 .node.clickable{cursor:pointer}#mermaid-1686152183322 .arrowheadPath{fill:#333}#mermaid-1686152183322 .edgePath .path{stroke:#333;stroke-width:1.5px}#mermaid-1686152183322 .edgeLabel{background-color:#e8e8e8}#mermaid-1686152183322 .cluster rect{fill:#ffffde!important;stroke:#aa3!important;stroke-width:1px!important}#mermaid-1686152183322 .cluster text{fill:#333}#mermaid-1686152183322 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:trebuchet ms,verdana,arial;font-size:12px;background:#ffffde;border:1px solid #aa3;border-radius:2px;pointer-events:none;z-index:100}#mermaid-1686152183322 .actor{stroke:#ccf;fill:#ececff}#mermaid-1686152183322 text.actor{fill:#000;stroke:none}#mermaid-1686152183322 .actor-line{stroke:grey}#mermaid-1686152183322 .messageLine0{marker-end:"url(#arrowhead)"}#mermaid-1686152183322 .messageLine0,#mermaid-1686152183322 .messageLine1{stroke-width:1.5;stroke-dasharray:"2 2";stroke:#333}#mermaid-1686152183322 #arrowhead{fill:#333}#mermaid-1686152183322 #crosshead path{fill:#333!important;stroke:#333!important}#mermaid-1686152183322 .messageText{fill:#333;stroke:none}#mermaid-1686152183322 .labelBox{stroke:#ccf;fill:#ececff}#mermaid-1686152183322 .labelText,#mermaid-1686152183322 .loopText{fill:#000;stroke:none}#mermaid-1686152183322 .loopLine{stroke-width:2;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#ccf}#mermaid-1686152183322 .note{stroke:#aa3;fill:#fff5ad}#mermaid-1686152183322 .noteText{fill:#000;stroke:none;font-family:trebuchet ms,verdana,arial;font-size:14px}#mermaid-1686152183322 .section{stroke:none;opacity:.2}#mermaid-1686152183322 .section0{fill:rgba(102,102,255,.49)}#mermaid-1686152183322 .section2{fill:#fff400}#mermaid-1686152183322 .section1,#mermaid-1686152183322 .section3{fill:#fff;opacity:.2}#mermaid-1686152183322 .sectionTitle0,#mermaid-1686152183322 .sectionTitle1,#mermaid-1686152183322 .sectionTitle2,#mermaid-1686152183322 .sectionTitle3{fill:#333}#mermaid-1686152183322 .sectionTitle{text-anchor:start;font-size:11px;text-height:14px}#mermaid-1686152183322 .grid .tick{stroke:#d3d3d3;opacity:.3;shape-rendering:crispEdges}#mermaid-1686152183322 .grid path{stroke-width:0}#mermaid-1686152183322 .today{fill:none;stroke:red;stroke-width:2px}#mermaid-1686152183322 .task{stroke-width:2}#mermaid-1686152183322 .taskText{text-anchor:middle;font-size:11px}#mermaid-1686152183322 .taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px}#mermaid-1686152183322 .taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}#mermaid-1686152183322 .taskText0,#mermaid-1686152183322 .taskText1,#mermaid-1686152183322 .taskText2,#mermaid-1686152183322 .taskText3{fill:#fff}#mermaid-1686152183322 .task0,#mermaid-1686152183322 .task1,#mermaid-1686152183322 .task2,#mermaid-1686152183322 .task3{fill:#8a90dd;stroke:#534fbc}#mermaid-1686152183322 .taskTextOutside0,#mermaid-1686152183322 .taskTextOutside1,#mermaid-1686152183322 .taskTextOutside2,#mermaid-1686152183322 .taskTextOutside3{fill:#000}#mermaid-1686152183322 .active0,#mermaid-1686152183322 .active1,#mermaid-1686152183322 .active2,#mermaid-1686152183322 .active3{fill:#bfc7ff;stroke:#534fbc}#mermaid-1686152183322 .activeText0,#mermaid-1686152183322 .activeText1,#mermaid-1686152183322 .activeText2,#mermaid-1686152183322 .activeText3{fill:#000!important}#mermaid-1686152183322 .done0,#mermaid-1686152183322 .done1,#mermaid-1686152183322 .done2,#mermaid-1686152183322 .done3{stroke:grey;fill:#d3d3d3;stroke-width:2}#mermaid-1686152183322 .doneText0,#mermaid-1686152183322 .doneText1,#mermaid-1686152183322 .doneText2,#mermaid-1686152183322 .doneText3{fill:#000!important}#mermaid-1686152183322 .crit0,#mermaid-1686152183322 .crit1,#mermaid-1686152183322 .crit2,#mermaid-1686152183322 .crit3{stroke:#f88;fill:red;stroke-width:2}#mermaid-1686152183322 .activeCrit0,#mermaid-1686152183322 .activeCrit1,#mermaid-1686152183322 .activeCrit2,#mermaid-1686152183322 .activeCrit3{stroke:#f88;fill:#bfc7ff;stroke-width:2}#mermaid-1686152183322 .doneCrit0,#mermaid-1686152183322 .doneCrit1,#mermaid-1686152183322 .doneCrit2,#mermaid-1686152183322 .doneCrit3{stroke:#f88;fill:#d3d3d3;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}#mermaid-1686152183322 .activeCritText0,#mermaid-1686152183322 .activeCritText1,#mermaid-1686152183322 .activeCritText2,#mermaid-1686152183322 .activeCritText3,#mermaid-1686152183322 .doneCritText0,#mermaid-1686152183322 .doneCritText1,#mermaid-1686152183322 .doneCritText2,#mermaid-1686152183322 .doneCritText3{fill:#000!important}#mermaid-1686152183322 .titleText{text-anchor:middle;font-size:18px;fill:#000}
#mermaid-1686152183322 g.classGroup text{fill:#9370db;stroke:none;font-family:trebuchet ms,verdana,arial;font-size:10px}#mermaid-1686152183322 g.classGroup rect{fill:#ececff;stroke:#9370db}#mermaid-1686152183322 g.classGroup line{stroke:#9370db;stroke-width:1}#mermaid-1686152183322 .classLabel .box{stroke:none;stroke-width:0;fill:#ececff;opacity:.5}#mermaid-1686152183322 .classLabel .label{fill:#9370db;font-size:10px}#mermaid-1686152183322 .relation{stroke:#9370db;stroke-width:1;fill:none}#mermaid-1686152183322 #compositionEnd,#mermaid-1686152183322 #compositionStart{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-1686152183322 #aggregationEnd,#mermaid-1686152183322 #aggregationStart{fill:#ececff;stroke:#9370db;stroke-width:1}#mermaid-1686152183322 #dependencyEnd,#mermaid-1686152183322 #dependencyStart,#mermaid-1686152183322 #extensionEnd,#mermaid-1686152183322 #extensionStart{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-1686152183322 .branch-label,#mermaid-1686152183322 .commit-id,#mermaid-1686152183322 .commit-msg{fill:#d3d3d3;color:#d3d3d3}</style> <style>#mermaid-1686152183322{color:#000;font:normal normal 400 normal 16px / normal "Times New Roman"}</style> <g></g><g><line id="actor0" x1="75" y1="5" x2="75" y2="336" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="0" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="75" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle;"><tspan x="75" dy="0">JVM</tspan></text></g><g><line id="actor1" x1="275" y1="5" x2="275" y2="336" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="200" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="275" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle;"><tspan x="275" dy="0">OS_Core</tspan></text></g><g><line id="actor2" x1="475" y1="5" x2="475" y2="336" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="400" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="475" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle;"><tspan x="475" dy="0">Disk</tspan></text></g><defs><marker id="arrowhead" refx="5" refy="2" markerwidth="6" markerheight="4" orient="auto"><path d="M 0,0 V 4 L6,2 Z"></path></marker></defs><defs><marker id="crosshead" markerwidth="15" markerheight="8" orient="auto" refx="16" refy="4"><path fill="black" stroke="#000000" stroke-width="1px" d="M 9,2 V 6 L16,4 Z" style="stroke-dasharray: 0, 0;"></path><path fill="none" stroke="#000000" stroke-width="1px" d="M 0,1 L 6,7 M 6,1 L 0,7" style="stroke-dasharray: 0, 0;"></path></marker></defs><g><text x="175" y="93" class="messageText" style="text-anchor: middle;">调用操作系统读取文件</text><line x1="75" y1="100" x2="275" y2="100" class="messageLine0" stroke-width="2" stroke="black" marker-end="url(#arrowhead)" style="fill: none;"></line></g><g><rect x="70" y="102" fill="#f4f4f4" stroke="#666" width="10" height="149" rx="0" ry="0"></rect></g><g><text x="375" y="128" class="messageText" style="text-anchor: middle;">调用磁盘读取文件</text><line x1="275" y1="135" x2="475" y2="135" class="messageLine0" stroke-width="2" stroke="black" marker-end="url(#arrowhead)" style="fill: none;"></line></g><g><rect x="470" y="137" fill="#f4f4f4" stroke="#666" width="10" height="33" rx="0" ry="0"></rect></g><g><text x="372.5" y="163" class="messageText" style="text-anchor: middle;">磁盘完成文件读取通知 OS</text><line x1="470" y1="170" x2="275" y2="170" class="messageLine0" stroke-width="2" stroke="black" marker-end="url(#arrowhead)" style="fill: none;"></line></g><g><rect x="270" y="172" fill="#f4f4f4" stroke="#666" width="10" height="79" rx="0" ry="0"></rect></g><g><rect x="300" y="180" fill="#EDF2AE" stroke="#666" width="150" height="36" rx="0" ry="0" class="note"></rect><text x="296" y="204" fill="black" class="noteText"><tspan x="316" fill="black">OS 拷贝数据到内核缓冲区</tspan></text></g><g><text x="175" y="244" class="messageText" style="text-anchor: middle;">OS 拷贝数据到用户缓冲区</text><line x1="270" y1="251" x2="80" y2="251" class="messageLine0" stroke-width="2" stroke="black" marker-end="url(#arrowhead)" style="fill: none;"></line></g><g><rect x="0" y="271" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="75" y="303.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle;"><tspan x="75" dy="0">JVM</tspan></text></g><g><rect x="200" y="271" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="275" y="303.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle;"><tspan x="275" dy="0">OS_Core</tspan></text></g><g><rect x="400" y="271" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="475" y="303.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle;"><tspan x="475" dy="0">Disk</tspan></text></g></svg> </div> <div class="caption"> JVM 读取文件的流程，整个读取过程中 JVM 的线程全程阻塞等待结果 </div> <p>NIO 和 BIO 的核心区别就是，调用 IO 操作的线程不再阻塞。我们使用伪代码的方式说明：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">NonBlockingFileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NonBlockFileInputStream</span><span class="o">(</span><span class="s">"/Users/tiger/test.txt"</span><span class="o">);</span> <span class="c1">// 创建非阻塞读取流，这里是为了说明逻辑，实际上并没有这个类</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">buf</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
<span class="kt">int</span> <span class="n">read</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buf</span><span class="o">);</span> <span class="c1">// 此方法不会阻塞线程，而是根据返回值标识读取结果</span>
<span class="k">while</span> <span class="o">(</span><span class="n">read</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">// 如果没有读到数据，循环</span>
	<span class="n">read</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buf</span><span class="o">);</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">buf</span><span class="o">));</span>
</code></pre></div></div> <p>因为线程没有阻塞，所以该线程就有可能同时处理多个文件的读取了。比如有多个文件输入流，我们就可以这样管理：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">NonBlockingFileInputStream</span><span class="o">&gt;</span> <span class="n">fisList</span> <span class="o">=</span> <span class="n">multiRead</span><span class="o">();</span> <span class="c1">// 假设该方法同时读取多个文件</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">NonBlockingFileInputStream</span> <span class="n">fis</span> <span class="o">:</span> <span class="n">fisList</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">byte</span><span class="o">[]</span> <span class="n">read</span> <span class="o">=</span> <span class="n">read</span><span class="o">(</span><span class="n">fis</span><span class="o">);</span> <span class="c1">// 如果读没有取到内容，返回 null</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">read</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">handleReadResult</span><span class="o">(</span><span class="n">read</span><span class="o">);</span> <span class="c1">// 处理读取内容</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>上面的代码简单说明了如何使用非阻塞读取的方式通过一个线程管理多个读取任务。</p> <div class="jekyll-diagrams diagrams mermaid"> <svg id="mermaid-1686152183911" width="100%" xmlns="http://www.w3.org/2000/svg" height="100%" style="max-width:450px;" viewbox="-50 -10 450 391"><style>#mermaid-1686152183911 .label{font-family:trebuchet ms,verdana,arial;color:#333}#mermaid-1686152183911 .node circle,#mermaid-1686152183911 .node ellipse,#mermaid-1686152183911 .node polygon,#mermaid-1686152183911 .node rect{fill:#ececff;stroke:#9370db;stroke-width:1px}#mermaid-1686152183911 .node.clickable{cursor:pointer}#mermaid-1686152183911 .arrowheadPath{fill:#333}#mermaid-1686152183911 .edgePath .path{stroke:#333;stroke-width:1.5px}#mermaid-1686152183911 .edgeLabel{background-color:#e8e8e8}#mermaid-1686152183911 .cluster rect{fill:#ffffde!important;stroke:#aa3!important;stroke-width:1px!important}#mermaid-1686152183911 .cluster text{fill:#333}#mermaid-1686152183911 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:trebuchet ms,verdana,arial;font-size:12px;background:#ffffde;border:1px solid #aa3;border-radius:2px;pointer-events:none;z-index:100}#mermaid-1686152183911 .actor{stroke:#ccf;fill:#ececff}#mermaid-1686152183911 text.actor{fill:#000;stroke:none}#mermaid-1686152183911 .actor-line{stroke:grey}#mermaid-1686152183911 .messageLine0{marker-end:"url(#arrowhead)"}#mermaid-1686152183911 .messageLine0,#mermaid-1686152183911 .messageLine1{stroke-width:1.5;stroke-dasharray:"2 2";stroke:#333}#mermaid-1686152183911 #arrowhead{fill:#333}#mermaid-1686152183911 #crosshead path{fill:#333!important;stroke:#333!important}#mermaid-1686152183911 .messageText{fill:#333;stroke:none}#mermaid-1686152183911 .labelBox{stroke:#ccf;fill:#ececff}#mermaid-1686152183911 .labelText,#mermaid-1686152183911 .loopText{fill:#000;stroke:none}#mermaid-1686152183911 .loopLine{stroke-width:2;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#ccf}#mermaid-1686152183911 .note{stroke:#aa3;fill:#fff5ad}#mermaid-1686152183911 .noteText{fill:#000;stroke:none;font-family:trebuchet ms,verdana,arial;font-size:14px}#mermaid-1686152183911 .section{stroke:none;opacity:.2}#mermaid-1686152183911 .section0{fill:rgba(102,102,255,.49)}#mermaid-1686152183911 .section2{fill:#fff400}#mermaid-1686152183911 .section1,#mermaid-1686152183911 .section3{fill:#fff;opacity:.2}#mermaid-1686152183911 .sectionTitle0,#mermaid-1686152183911 .sectionTitle1,#mermaid-1686152183911 .sectionTitle2,#mermaid-1686152183911 .sectionTitle3{fill:#333}#mermaid-1686152183911 .sectionTitle{text-anchor:start;font-size:11px;text-height:14px}#mermaid-1686152183911 .grid .tick{stroke:#d3d3d3;opacity:.3;shape-rendering:crispEdges}#mermaid-1686152183911 .grid path{stroke-width:0}#mermaid-1686152183911 .today{fill:none;stroke:red;stroke-width:2px}#mermaid-1686152183911 .task{stroke-width:2}#mermaid-1686152183911 .taskText{text-anchor:middle;font-size:11px}#mermaid-1686152183911 .taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px}#mermaid-1686152183911 .taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}#mermaid-1686152183911 .taskText0,#mermaid-1686152183911 .taskText1,#mermaid-1686152183911 .taskText2,#mermaid-1686152183911 .taskText3{fill:#fff}#mermaid-1686152183911 .task0,#mermaid-1686152183911 .task1,#mermaid-1686152183911 .task2,#mermaid-1686152183911 .task3{fill:#8a90dd;stroke:#534fbc}#mermaid-1686152183911 .taskTextOutside0,#mermaid-1686152183911 .taskTextOutside1,#mermaid-1686152183911 .taskTextOutside2,#mermaid-1686152183911 .taskTextOutside3{fill:#000}#mermaid-1686152183911 .active0,#mermaid-1686152183911 .active1,#mermaid-1686152183911 .active2,#mermaid-1686152183911 .active3{fill:#bfc7ff;stroke:#534fbc}#mermaid-1686152183911 .activeText0,#mermaid-1686152183911 .activeText1,#mermaid-1686152183911 .activeText2,#mermaid-1686152183911 .activeText3{fill:#000!important}#mermaid-1686152183911 .done0,#mermaid-1686152183911 .done1,#mermaid-1686152183911 .done2,#mermaid-1686152183911 .done3{stroke:grey;fill:#d3d3d3;stroke-width:2}#mermaid-1686152183911 .doneText0,#mermaid-1686152183911 .doneText1,#mermaid-1686152183911 .doneText2,#mermaid-1686152183911 .doneText3{fill:#000!important}#mermaid-1686152183911 .crit0,#mermaid-1686152183911 .crit1,#mermaid-1686152183911 .crit2,#mermaid-1686152183911 .crit3{stroke:#f88;fill:red;stroke-width:2}#mermaid-1686152183911 .activeCrit0,#mermaid-1686152183911 .activeCrit1,#mermaid-1686152183911 .activeCrit2,#mermaid-1686152183911 .activeCrit3{stroke:#f88;fill:#bfc7ff;stroke-width:2}#mermaid-1686152183911 .doneCrit0,#mermaid-1686152183911 .doneCrit1,#mermaid-1686152183911 .doneCrit2,#mermaid-1686152183911 .doneCrit3{stroke:#f88;fill:#d3d3d3;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}#mermaid-1686152183911 .activeCritText0,#mermaid-1686152183911 .activeCritText1,#mermaid-1686152183911 .activeCritText2,#mermaid-1686152183911 .activeCritText3,#mermaid-1686152183911 .doneCritText0,#mermaid-1686152183911 .doneCritText1,#mermaid-1686152183911 .doneCritText2,#mermaid-1686152183911 .doneCritText3{fill:#000!important}#mermaid-1686152183911 .titleText{text-anchor:middle;font-size:18px;fill:#000}
#mermaid-1686152183911 g.classGroup text{fill:#9370db;stroke:none;font-family:trebuchet ms,verdana,arial;font-size:10px}#mermaid-1686152183911 g.classGroup rect{fill:#ececff;stroke:#9370db}#mermaid-1686152183911 g.classGroup line{stroke:#9370db;stroke-width:1}#mermaid-1686152183911 .classLabel .box{stroke:none;stroke-width:0;fill:#ececff;opacity:.5}#mermaid-1686152183911 .classLabel .label{fill:#9370db;font-size:10px}#mermaid-1686152183911 .relation{stroke:#9370db;stroke-width:1;fill:none}#mermaid-1686152183911 #compositionEnd,#mermaid-1686152183911 #compositionStart{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-1686152183911 #aggregationEnd,#mermaid-1686152183911 #aggregationStart{fill:#ececff;stroke:#9370db;stroke-width:1}#mermaid-1686152183911 #dependencyEnd,#mermaid-1686152183911 #dependencyStart,#mermaid-1686152183911 #extensionEnd,#mermaid-1686152183911 #extensionStart{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-1686152183911 .branch-label,#mermaid-1686152183911 .commit-id,#mermaid-1686152183911 .commit-msg{fill:#d3d3d3;color:#d3d3d3}</style> <style>#mermaid-1686152183911{color:#000;font:normal normal 400 normal 16px / normal "Times New Roman"}</style> <g></g><g><line id="actor0" x1="75" y1="5" x2="75" y2="380" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="0" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="75" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle;"><tspan x="75" dy="0">JVM</tspan></text></g><g><line id="actor1" x1="275" y1="5" x2="275" y2="380" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="200" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="275" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle;"><tspan x="275" dy="0">OS_Core</tspan></text></g><defs><marker id="arrowhead" refx="5" refy="2" markerwidth="6" markerheight="4" orient="auto"><path d="M 0,0 V 4 L6,2 Z"></path></marker></defs><defs><marker id="crosshead" markerwidth="15" markerheight="8" orient="auto" refx="16" refy="4"><path fill="black" stroke="#000000" stroke-width="1px" d="M 9,2 V 6 L16,4 Z" style="stroke-dasharray: 0, 0;"></path><path fill="none" stroke="#000000" stroke-width="1px" d="M 0,1 L 6,7 M 6,1 L 0,7" style="stroke-dasharray: 0, 0;"></path></marker></defs><g><text x="175" y="143" class="messageText" style="text-anchor: middle;">get read result</text><line x1="75" y1="150" x2="275" y2="150" class="messageLine0" stroke-width="2" stroke="black" marker-end="url(#arrowhead)" style="fill: none;"></line></g><g><text x="175" y="178" class="messageText" style="text-anchor: middle;">null</text><line x1="275" y1="185" x2="75" y2="185" class="messageLine0" stroke-width="2" stroke="black" marker-end="url(#arrowhead)" style="fill: none;"></line></g><g><line x1="65" y1="100" x2="285" y2="100" class="loopLine"></line><line x1="285" y1="100" x2="285" y2="195" class="loopLine"></line><line x1="65" y1="195" x2="285" y2="195" class="loopLine"></line><line x1="65" y1="100" x2="65" y2="195" class="loopLine"></line><polygon points="65,100 115,100 115,113 106.6,120 65,120" class="labelBox"></polygon><text x="72.5" y="115" fill="black" class="labelText"><tspan x="72.5" fill="black">loop</tspan></text><text x="175" y="115" fill="black" class="loopText" style="text-anchor: middle;"><tspan x="175" fill="black">[ 轮询 ]</tspan></text></g><g><text x="175" y="243" class="messageText" style="text-anchor: middle;">get read result</text><line x1="75" y1="250" x2="275" y2="250" class="messageLine0" stroke-width="2" stroke="black" marker-end="url(#arrowhead)" style="fill: none;"></line></g><g><rect x="270" y="252" fill="#f4f4f4" stroke="#666" width="10" height="33" rx="0" ry="0"></rect></g><g><text x="172.5" y="278" class="messageText" style="text-anchor: middle;">byte array</text><line x1="270" y1="285" x2="75" y2="285" class="messageLine0" stroke-width="2" stroke="black" marker-end="url(#arrowhead)" style="fill: none;"></line></g><g><line x1="55" y1="75" x2="295" y2="75" class="loopLine"></line><line x1="295" y1="75" x2="295" y2="295" class="loopLine"></line><line x1="55" y1="295" x2="295" y2="295" class="loopLine"></line><line x1="55" y1="75" x2="55" y2="295" class="loopLine"></line><line x1="55" y1="205" x2="295" y2="205" class="loopLine" style="stroke-dasharray: 3, 3;"></line><polygon points="55,75 105,75 105,88 96.6,95 55,95" class="labelBox"></polygon><text x="62.5" y="90" fill="black" class="labelText"><tspan x="62.5" fill="black">alt</tspan></text><text x="175" y="90" fill="black" class="loopText" style="text-anchor: middle;"><tspan x="175" fill="black">[ 操作系统未完成读取 ]</tspan></text><text x="175" y="220" fill="black" class="loopText" style="text-anchor: middle;"><tspan x="175" fill="black">[ 操作系统完成文件读取 ]</tspan></text></g><g><rect x="0" y="315" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="75" y="347.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle;"><tspan x="75" dy="0">JVM</tspan></text></g><g><rect x="200" y="315" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="275" y="347.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle;"><tspan x="275" dy="0">OS_Core</tspan></text></g></svg> </div> <div class="caption"> 非阻塞读取文件，当前线程一直在运行中 </div> <p>这里有个问题，既然 BIO 已经可以实现 IO 操作，为什么还要推出一套 NIO 体系呢？要理解这个问题，我们需要通过网络 IO 来进行说明，因为 NIO 主要是为了优化网络 IO 模型的。</p> <p>我们通常使用网络 IO 来实现 B/S 和 C/S 架构，就是浏览器和客户端访问网络服务器做数据交互。这些架构有个共同特点：客户端的数量远大于服务器的数量，一台服务器需要支持多个客户端的网络传输。使用传统的 BIO 模型，服务器在从网络 <code class="language-plaintext highlighter-rouge">socket</code> 中读取或写入数据时，当前线程是阻塞的，这时如果有其他客户端也在请求服务器，当前线程无法响应。这肯定是不可接受的。所以使用传统 BIO 模型，服务器端一定是通过多线程的方式支持并发请求。客户端一旦连接服务器，服务器就创建一个线程去单独处理该客户端的请求。但一台服务器能同时运行的线程数量是有限的，因为服务器内存是有限的。并且线程在处理网络 IO 的过程中也会阻塞，也就是说服务器的内存被大量占用，却没有得到高效的利用。这是 BIO 模型的弊端。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/bio-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/bio-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/bio-1400.webp"></source> <img src="/assets/img/bio.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> BIO 的服务器线程模型 </div> <p>而 NIO 尝试解决 BIO 的弊端。NIO 在处理 IO 请求时，当前线程不会阻塞，这就可以实现通过一个线程管理多个客户端的 IO 请求，在一定程度上提高了服务器资源的利用率。但我们在上面的 NIO 例子中也会发现一个问题，就是无论当前有没有 IO 请求，线程会一直空转下去，这是对 CPU 资源的浪费。我们可以看一下JVM 是如何通过自己的 NIO 模型解决这个问题的。</p> <h1 id="nio-的核心组件">NIO 的核心组件</h1> <p>NIO 有三大核心组件。分别是 <code class="language-plaintext highlighter-rouge">Selector</code>、<code class="language-plaintext highlighter-rouge">Channel</code> 和 <code class="language-plaintext highlighter-rouge">ByteBuffer</code>。我们分别介绍这些组件的作用。</p> <h2 id="bytebuffer-缓冲区">ByteBuffer 缓冲区</h2> <p>ByteBuffer 顾名思义，就是在 IO 过程中的数据缓冲区，有些类似于我们在上面例子中的字节数组，但 ByteBuffer 封装了很多实用的方法，比字节数组功能更强大。我们先看一下 <code class="language-plaintext highlighter-rouge">ByteBuffer</code> 的类结构：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/byte-buffer-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/byte-buffer-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/byte-buffer-1400.webp"></source> <img src="/assets/img/byte-buffer.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>可以看到，<code class="language-plaintext highlighter-rouge">ByteBuffer</code> 是一个抽象类，它有两个实现体系，分别是 <code class="language-plaintext highlighter-rouge">MappedByteBuffer</code> 和 <code class="language-plaintext highlighter-rouge">HeapByteBuffer</code>，其中以 “R” 为后缀的实现类表示只读缓存。从类名我们就可以看出端倪，<code class="language-plaintext highlighter-rouge">HeapByteBuffer</code> 是直接申请在 JVM 堆内存上的缓冲区，而 <code class="language-plaintext highlighter-rouge">MappedByteBuffer</code> 则是映射到系统内存上的缓冲区，被称作“直接缓存”，直接缓存是操作系统的内存空间，需要我们自行管理这部分内存，防止出现内存泄漏。</p> <p>ByteBuffer 是 Buffer 体系下最常用的类。Buffer 还包括其他基本类型的实现，如 <code class="language-plaintext highlighter-rouge">CharBuffer</code>、<code class="language-plaintext highlighter-rouge">DoubleBuffer</code> 等，具体可以参考 JVM 的 API 文档。</p> <p>注意，ByteBuffer 不是线程安全的，多线程编程下需要注意状态的同步控制。</p> <h3 id="buffer-的底层原理">Buffer 的底层原理</h3> <p>Buffer 是所有缓冲区实现类的父类，它定义了一个线性的有限序列，用来存放原始数据类型。Buffer 有三个重要属性，分别是：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">capacity</code>。表示当前缓冲区能存放的最大元素数量。缓冲区一旦创建，容量便不会更改。</li> <li> <code class="language-plaintext highlighter-rouge">limit</code>。表示当前缓冲区可以读/写的终点索引。范围是 [0, capacity]。</li> <li> <code class="language-plaintext highlighter-rouge">position</code>。表示当前缓冲区下一个可以读/写的元素索引。范围是 [0, limit]。</li> </ul> <p>缓冲区有两种操作模式：<code class="language-plaintext highlighter-rouge">读模式(get)</code> 和 <code class="language-plaintext highlighter-rouge">写模式(put)</code>。假设创建一个 8 字节的缓冲区：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ByteBuffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nc">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="mi">8</span><span class="o">);</span>
</code></pre></div></div> <p>我们用图表示一下缓冲区各个状态之间的变化：</p> <h4 id="初始化">初始化</h4> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/buffer-init-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/buffer-init-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/buffer-init-1400.webp"></source> <img src="/assets/img/buffer-init.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> 初始化缓冲区 </div> <p>初始化完成后字节数组中所有元素的起始值都是 0。<code class="language-plaintext highlighter-rouge">position</code> = 0，<code class="language-plaintext highlighter-rouge">limit</code> = <code class="language-plaintext highlighter-rouge">capacity</code>。</p> <h4 id="写入数据">写入数据</h4> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/buffer-write-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/buffer-write-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/buffer-write-1400.webp"></source> <img src="/assets/img/buffer-write.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> 向缓冲区写入数据 </div> <p>缓冲区写入部分数据后，<code class="language-plaintext highlighter-rouge">position</code> 向后移动，指向下一个要写入的位置。如果写入的数据超过缓冲区的容量，导致 <code class="language-plaintext highlighter-rouge">position == limit</code>，此时再写入就会抛出 <code class="language-plaintext highlighter-rouge">BufferOverflowException</code> 。</p> <h4 id="切换到读模式">切换到读模式</h4> <p>当缓冲区写入部分数据后，调用缓冲区的 <code class="language-plaintext highlighter-rouge">flip()</code> 方法，将缓冲区转换为读模式。<code class="language-plaintext highlighter-rouge">flip()</code> 方法做的事情很简单，我们直接看源码：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="nc">Buffer</span> <span class="nf">flip</span><span class="o">()</span> <span class="o">{</span>  
    <span class="n">limit</span> <span class="o">=</span> <span class="n">position</span><span class="o">;</span> <span class="c1">// 将 limit 重置为当前 position 的值，表示最多读到这里</span>
    <span class="n">position</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// position 重置为 0，表示从头开始读</span>
    <span class="n">mark</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// 辅助参数，这里不展开</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">;</span> <span class="c1">// 返回当前缓冲区对象</span>
<span class="o">}</span>
</code></pre></div></div> <p>调用 <code class="language-plaintext highlighter-rouge">flip()</code> 方法后缓冲区变为：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/buffer-read-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/buffer-read-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/buffer-read-1400.webp"></source> <img src="/assets/img/buffer-read.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> 缓冲区转变为读模式 </div> <h4 id="切换到写模式">切换到写模式</h4> <p>当缓冲区的数据读取完之后，调用 <code class="language-plaintext highlighter-rouge">clear()</code> 方法，将缓冲区重置为初始化的状态。</p> <p>当读取了缓冲区部分数据后，如果此时想立即切换到读模式，可以调用 <code class="language-plaintext highlighter-rouge">compact()</code> 方法压缩缓冲区，把已经读取的部分移除，把未读取的部分往前移：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/buffer-compact-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/buffer-compact-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/buffer-compact-1400.webp"></source> <img src="/assets/img/buffer-compact.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> 压缩缓冲区并进入写模式 </div> <h2 id="channel-通道">Channel 通道</h2> <p><code class="language-plaintext highlighter-rouge">Channel</code> 相当于 NIO 模型中的流，表示 JVM 应用和一个支持 I/O 操作的设备或组件的连接，如硬盘、Socket、文件等。<code class="language-plaintext highlighter-rouge">Channel</code> 支持双向传输，既可以读，也可以写。程序不能直接访问 <code class="language-plaintext highlighter-rouge">Channel</code> 中的数据，需要通过 <code class="language-plaintext highlighter-rouge">Buffer</code> 作为中介。<code class="language-plaintext highlighter-rouge">Channel</code> 还提供了 <code class="language-plaintext highlighter-rouge">map()</code> 方法，支持将“一块”数据直接映射到系统内存中。常见的 <code class="language-plaintext highlighter-rouge">Channel</code> 实现包括：</p> <ul> <li>FileChannel。用于文件读写；</li> <li>SocketChannel &amp; ServerSocketChannel。用于实现 TCP 客户端服务端通信；</li> <li>DatagramChannel。用于实现 UDP 通信；</li> </ul> <p>如下图所示：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/channel-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/channel-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/channel-1400.webp"></source> <img src="/assets/img/channel.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>注意类图中的 <code class="language-plaintext highlighter-rouge">SelectableChannel</code> 类，该类表示可以被下面提到的选择器进行管理。<code class="language-plaintext highlighter-rouge">FileChannel</code> 没有继承该类，表示文件相关的 I/O 不支持选择器操作，也就是说不支持非阻塞操作。</p> <p>默认情况下，<code class="language-plaintext highlighter-rouge">Channel</code> 对象都是工作在阻塞模式下的，可以通过下面的方法修改：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SocketChannel</span><span class="o">.</span><span class="na">configureBlocking</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span> <span class="c1">// 指定当前通道为非阻塞模式</span>
</code></pre></div></div> <h2 id="selector-选择器">Selector 选择器</h2> <p><code class="language-plaintext highlighter-rouge">SelectableChannel</code> 对象的多路复用器。选择器可以同时管理多个通道对象，当发生通道关注的事件时，通知对应的通道对象进行处理。</p> <p><code class="language-plaintext highlighter-rouge">SelectableChannel</code> 的子类实现了 <code class="language-plaintext highlighter-rouge">register()</code> 方法，通道调用该方法，即可注册到指定的 <code class="language-plaintext highlighter-rouge">Selector</code> 对象上：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 注册到指定的选择器上
 * @param sel 选择器对象
 * @param ops 通道关注的事件
 * @param att 附件
 * @return SelectionKey 通道的注册结果，对象中包含对应的通道和选择器以及操作方法
 */</span>
<span class="nc">SelectionKey</span> <span class="nc">SelectableChannel</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="nc">Selector</span> <span class="n">sel</span><span class="o">,</span> <span class="kt">int</span> <span class="n">ops</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">att</span><span class="o">);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Selector</code> 支持 4 种事件：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SelectionKey</span><span class="o">.</span><span class="na">OP_READ</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="o">;</span>    <span class="c1">// 读就绪，发生在 SocketChannel 和 DatagramChannel，表示当前通道中有数据了，可以执行读到做</span>
<span class="nc">SelectionKey</span><span class="o">.</span><span class="na">OP_WRITE</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="o">;</span>   <span class="c1">// 写就绪，发生在 SocketChannel 和 DatagramChannel，表示可以向当前通道写入数据</span>
<span class="nc">SelectionKey</span><span class="o">.</span><span class="na">OP_CONNECT</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="o">;</span> <span class="c1">// 连接就绪，发生在 SocketChannel，表示客户端和服务端成功建立连接</span>
<span class="nc">SelectionKey</span><span class="o">.</span><span class="na">OP_ACCEPT</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="o">;</span>  <span class="c1">// 连接就绪，发生在 ServerSocketChanne，表示服务端至少接入了一个客户端，可以通过 accept() 方法获取对应的 SocketChannel 了</span>
</code></pre></div></div> <p>关注事件可以在通道注册时指定，也可以通过 <code class="language-plaintext highlighter-rouge">SelectionKey</code> 对象添加：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SelectionKey</span> <span class="nc">SelectionKey</span><span class="o">.</span><span class="na">interestOps</span><span class="o">(</span><span class="kt">int</span> <span class="n">ops</span><span class="o">);</span>
</code></pre></div></div> <p>我们上面提到过非阻塞 I/O 的一个弊端就是会导致线程空转，浪费 CPU 资源。<code class="language-plaintext highlighter-rouge">Selector</code> 解决了这个问题。<code class="language-plaintext highlighter-rouge">Selector</code> 同时支持阻塞和非阻塞模式获取事件通知：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">selectNow</span><span class="o">();</span> <span class="c1">// 该方法工作在非阻塞模式，无论有没有事件发生，调用该方法会立即返回</span>
<span class="kt">int</span> <span class="nf">select</span><span class="o">();</span> <span class="c1">// 该方法调用后会阻塞，直到有关注的事件发生才会返回</span>
<span class="kt">int</span> <span class="nf">select</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">);</span> <span class="c1">// 该方法可以指定阻塞时间</span>
</code></pre></div></div> <h1 id="nio-的底层原理">NIO 的底层原理</h1> <p>我们首先了解一下操作系统常见的 5 种 I/O 模型。</p> <ol> <li>Blocking I/O 阻塞式 I/O；</li> <li>Non-blocking I/O 非阻塞式 I/O；</li> <li>I/O multiplexing I/O (select and poll) 多路复用；</li> <li>Signal driven I/O (SIGIO) 信号驱动 I/O；</li> <li>Asynchronous I/O (the POXIS aio_functions) 异步 I/O；</li> </ol> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/io-model-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/io-model-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/io-model-1400.webp"></source> <img src="/assets/img/io-model.jpeg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>这 5 种 I/O 模型，使用 <code class="language-plaintext highlighter-rouge">同步/异步</code> 、<code class="language-plaintext highlighter-rouge">阻塞/非阻塞</code> 分类：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/io-model2-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/io-model2-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/io-model2-1400.webp"></source> <img src="/assets/img/io-model2.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>前面已经介绍过 BIO 和 NIO 的区别，而 Java 的 NIO 模型，实际上就是 <em>多路复用</em>。</p> <p>目前主流的多路复用 I/O 实现主要有四种：<code class="language-plaintext highlighter-rouge">select</code>、<code class="language-plaintext highlighter-rouge">poll</code>、<code class="language-plaintext highlighter-rouge">epoll</code>、<code class="language-plaintext highlighter-rouge">kqueue</code>。下表是它们的一些重要特性和比较：</p> <table> <thead> <tr> <th>IO 模型</th> <th>相对性能</th> <th>关键思路</th> <th>操作系统</th> <th>Java 支持情况</th> </tr> </thead> <tbody> <tr> <td>select</td> <td>较高</td> <td>Reactor</td> <td>Windows/Linux</td> <td>支持，Reactor模式（反应器设计模式）。Linux 操作系统的 kernels 2.4 内核版本之前，默认使用 <code class="language-plaintext highlighter-rouge">select</code>；而目前 windows 下对同步 IO 的支持，都是 <code class="language-plaintext highlighter-rouge">select</code> 模型</td> </tr> <tr> <td>poll</td> <td>较高</td> <td>Reactor</td> <td>Linux</td> <td>Linux 下的 Java NIO 框架，Linux kernels 2.6 内核版本之前使用 <code class="language-plaintext highlighter-rouge">poll</code> 支持。也是使用 Reactor 模式</td> </tr> <tr> <td>epoll</td> <td>高</td> <td>Reactor/Proactor</td> <td>Linux</td> <td>Linux kernels 2.6 内核版本及之后使用 <code class="language-plaintext highlighter-rouge">epoll</code> 进行支持。另外需要注意，由于 Linux 下没有 windows 的 IOCP 技术提供真正的 <code class="language-plaintext highlighter-rouge">异步 IO</code> 支持，所以 Linux 下使用 <code class="language-plaintext highlighter-rouge">epoll</code> 模拟异步 IO</td> </tr> <tr> <td>kqueue</td> <td>高</td> <td>Proactor</td> <td>Linux</td> <td>目前 Java 不支持</td> </tr> </tbody> </table> <p>多路复用技术最适用于“高并发”场景，所谓高并发是指 1 ms 内至少同时有上千个连接请求准备好。其他情况下多路复用技术不能发挥优势。另一方面，使用 Java NIO 进行功能实现，相对于传统 <code class="language-plaintext highlighter-rouge">Socket</code> 实现要复杂一些。在实际应用中，要根据自己的业务需求进行技术选择。</p> <h2 id="java-nio-和-os-的交互">Java NIO 和 OS 的交互</h2> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/java-nio-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/java-nio-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/java-nio-1400.webp"></source> <img src="/assets/img/java-nio.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <h1 id="参考">参考</h1> <ul> <li><a href="https://learn.lianglianglee.com/%E6%96%87%E7%AB%A0/Java%20IO%20%E4%BD%93%E7%B3%BB%E3%80%81%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%A4%A7%E6%80%BB%E7%BB%93.md" rel="external nofollow noopener" target="_blank">Java IO 体系、线程模型大总结</a></li> <li><a href="https://learn.lianglianglee.com/%E6%96%87%E7%AB%A0/Java%20NIO%E6%B5%85%E6%9E%90.md" rel="external nofollow noopener" target="_blank">Java NIO 浅析</a></li> <li><a href="https://pdai.tech/md/java/io/java-io-nio-select-epoll.html" rel="external nofollow noopener" target="_blank">IO 多路复用详解</a></li> </ul> </article><div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"wzm001/wzm001.github.io","data-repo-id":"R_kgDOG5N29g","data-category":"Announcements","data-category-id":"DIC_kwDOG5N29s4CUo0g","data-mapping":"title","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Jimmy Wu. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>