<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>数据库事务 | Jimmy Wu</title> <meta name="author" content="Jimmy Wu"> <meta name="description" content="数据库事务的相关概念以及处理"> <meta name="keywords" content="Java, 后端, Software Developer"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/icon.png#%20the%20emoji%20used%20as%20the%20favicon%20(alternatively,%20provide%20image%20name%20in%20/assets/img/)"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://wzm001.github.io//blog/2023/database-transactions/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "数据库事务",
      "description": "数据库事务的相关概念以及处理",
      "published": "March 3, 2023",
      "authors": [
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Jimmy Wu</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">关于我</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">博客<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">项目</a> </li> <li class="nav-item "> <a class="nav-link" href="/assets/pdf/cv.pdf">简历</a> </li> <li class="nav-item "> <a class="nav-link" href="/assets/pdf/ecv.pdf">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>数据库事务</h1> <p>数据库事务的相关概念以及处理</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5">事务的概念</a></div> <div><a href="#%E4%BA%8B%E5%8A%A1%E7%9A%84acid%E5%B1%9E%E6%80%A7">事务的ACID属性</a></div> <div><a href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">事务的隔离级别</a></div> <ul> <li><a href="#%E9%94%81">锁</a></li> <li><a href="#%E8%84%8F%E5%86%99-dirty-write">脏写 Dirty Write</a></li> <li><a href="#%E8%84%8F%E8%AF%BB-dirty-read">脏读 Dirty Read</a></li> <li><a href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-fuzzy-read-non-repeatable-read">不可重复读 Fuzzy Read / Non-repeatable Read</a></li> <li><a href="#%E5%B9%BB%E8%AF%BB-phantom-read">幻读 Phantom Read</a></li> <li><a href="#%E4%B8%A2%E5%A4%B1%E6%9B%B4%E6%96%B0-lost-update">丢失更新 Lost Update</a></li> <li><a href="#%E8%AF%BB%E5%81%8F%E5%BA%8F-read-skew">读偏序 Read Skew</a></li> <li><a href="#%E5%86%99%E5%81%8F%E5%BA%8F-write-skew">写偏序 Write Skew</a></li> <li><a href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%B1%87%E6%80%BB">隔离级别汇总</a></li> </ul> <div><a href="#%E6%80%BB%E7%BB%93">总结</a></div> </nav> </d-contents> <h1 id="事务的概念">事务的概念</h1> <p>在数据系统的使用过程中，任何问题都可能发生：</p> <ul> <li>系统侧：数据库系统和硬件系统在任何时间都有可能发生故障；</li> <li>应用侧：使用数据库的应用程序任何时间都可能发生故障；</li> <li>网络侧：应用程序和数据库之间，数据库的多个节点间，随时可能发生网络断开；</li> <li>多个客户端：并发读写时，可能发生冲突；</li> <li>半读：一个客户端可能读到部分更新的数据；</li> </ul> <p>等等。这些问题大大增加了应用端的编程复杂度，因此在数据系统一侧抽象出<strong>事务</strong>的概念，将这些复杂性封装到事务内部处理，对外保证一个安全的使用环境，简化应用侧的编程模型。</p> <p>简单来说，<strong>事务</strong>就是将一组语句（或者说操作）打包为一个逻辑单元进行执行，并提供保证，这一组操作要么全部成功（commit，变更应用到数据库）或者全部失败（被动abort或主动rollback），而不会存在中间状态。此外，如果多个客户端并发执行，会涉及到事务隔离的问题，一般来说，数据库允许用户在隔离级别和性能之间做选择。</p> <p>有了事务在语义上的保证，用户就可以在事务失败后放心地进行重试，直到成功。但任何便利性都有代价，事务就是在一定程度上牺牲了性能和可用性。</p> <blockquote> <p>注：这里提到的事务失败后重试，是有局限性的。实际过程中重试可能会引发其他问题，需要特别注意：</p> <ol> <li>如果事务已经成功，只是在确认过程中出现了网络故障导致应用端以为事务失败了，这时触发重试可能会导致事务重复执行，除非有应用级别的去重机制；</li> <li>如果错误是由于数据库负载过大引起的，重试只会让问题变得更糟。这种情况下应该限制重试次数，使用指数退避算法，或单独处理负载相关的错误；</li> <li>在临时性的错误上重试是有意义的，例如网络异常、死锁等，如果发生永久性错误比如违反数据库约束，重试没有任何意义；</li> <li>如果事务在数据库之外有副作用，比如发送邮件等操作，即使事务失败，该副作用也有可能发生，这时重试有可能多次触发该副作用；</li> </ol> </blockquote> <h1 id="事务的acid属性">事务的ACID属性</h1> <h3 id="原子性-atomicity">原子性 Atomicity</h3> <p>原子性保证了当事务发生错误终止时，将当前事务的所有写入都丢弃，数据库回滚到事务开始前的状态。</p> <h3 id="一致性-consistency">一致性 Consistency</h3> <p>一致性指的是，从任意一个时间点查看数据，数据都需要满足业务规定的约束，比如会计系统要求所有账户整理借贷相抵。 但一致性的要求不是数据库本身可以保证的，数据库无法阻止客户端写入不符合约束的数据，因此该属性不应该是数据本身的属性，而应该是应用程序的属性。</p> <h3 id="隔离性-isolation">隔离性 Isolation</h3> <p>多个客户端同时执行的事务，彼此互不影响，相互隔离，每个事务都认为自己是系统中唯一正在执行的事务，表现出来就是所有事务都依次串行执行。但这么强的隔离性会大大降低数据库的吞吐量，因此实际使用中很少采用，数据库提供了串行化之外的几种弱隔离级别，根据数据库对事务的不同隔离级别，会有不同的隔离表现。</p> <h3 id="持久性-durability">持久性 Durability</h3> <p>持久性保证一旦事务提交，事务写入的数据就永久应用到数据库中，不会发生丢失。这个保证是在数据库自身的能力范围内，如果对数据的安全性有更高的要求，需要采用额外的措施，如强制刷盘、异地复制、定时备份等，但也只能大概率保证数据不丢失（比如5个9），无法绝对保证。</p> <h1 id="事务的隔离级别">事务的隔离级别</h1> <p>事务隔离级别的定义经历了几个发展阶段，这些不是本篇的主题，因此不再赘述，感兴趣的朋友可以阅读<a href="https://catkang.github.io/2018/08/31/isolation-level.html" rel="external nofollow noopener" target="_blank">这里</a>。</p> <p>前面提到，为了提高性能，数据库提供了几种弱隔离级别，这些隔离级别是通过可能遇到的并发问题（异相）来定义的。这里我们讨论一下每种异相的定义，以及阻止它的隔离级别，还有如何通过锁实现该隔离级别（也有其他实现方式，这里不展开）。</p> <p>先给出用到的锁的定义。</p> <h2 id="锁">锁</h2> <ul> <li>从锁的粒度看，我们把锁分为了对象锁（Record Lock, Row Lock）和谓词锁（Predicate Lock）。谓词锁可以锁定一个数据集，例如 SQL <code class="language-plaintext highlighter-rouge">select * from t where id &gt; 10;</code> 如果加谓词锁，就锁住了 id 从 10 到无穷大的范围，而不关注表里是否有对应的记录；</li> <li>从加锁的时长看，我们把锁分为长锁（Long Duration Lock）和短锁（Short Duration Lock）；短锁即语句执行前加锁，执行完释放锁；长锁即事务开始前加锁，事务结束后释放锁；</li> <li>从锁的互斥角度看，我们把锁分为了共享锁（Shared Lock，又称读锁）和互斥锁（Mutex Lock，又称写锁，独占锁）；同一条记录可以添加多个共享锁，但只能添加一个互斥锁；</li> </ul> <h2 id="脏写-dirty-write">脏写 Dirty Write</h2> <p>一个事务对数据进行写操作后，还没有提交，就被另一个事务对相同数据的写操作覆盖。（有资料称之为“第一类丢失更新”）</p> <p>举例：（x 的初始值为0）</p> <table> <thead> <tr> <th>时序</th> <th>事务A</th> <th>事务B</th> </tr> </thead> <tbody> <tr> <td>T1</td> <td>begin</td> <td>begin</td> </tr> <tr> <td>T2</td> <td>写x, x=1</td> <td> </td> </tr> <tr> <td>T3</td> <td> </td> <td>写x, x=2</td> </tr> <tr> <td>T4</td> <td>commit</td> <td> </td> </tr> <tr> <td>T5</td> <td> </td> <td>commit</td> </tr> </tbody> </table> <p>这里事务A将x写为1之后，还没有提交，就被事务B覆盖了。</p> <h3 id="问题">问题</h3> <p>脏写首先会导致事务无法回滚。假设事务A在T4要回滚，这时x已经被事务B写为2了，如果把x回滚为事务A修改之前的初始值0，则事务B的写入就丢失了；如果事务A事务B在T5也要回滚x，x在事务B修改前的值为1，由于事务A回滚，1这个值已经是脏数据，导致事务都没办法回滚，影响了事务的原子性。</p> <p>另外，脏写还会影响数据一致性。</p> <p>例如有两个值x和y，要求x和y始终相等，现在有两个事务同时修改x和y：</p> <table> <thead> <tr> <th>时序</th> <th>事务A</th> <th>事务B</th> </tr> </thead> <tbody> <tr> <td>T1</td> <td>begin</td> <td>begin</td> </tr> <tr> <td>T2</td> <td>写x, x=2</td> <td> </td> </tr> <tr> <td>T3</td> <td> </td> <td>写x, x=3</td> </tr> <tr> <td>T4</td> <td> </td> <td>写y, y=3</td> </tr> <tr> <td>T5</td> <td>写y, y=2</td> <td> </td> </tr> <tr> <td>T6</td> <td>commit</td> <td> </td> </tr> <tr> <td>T7</td> <td> </td> <td>commit</td> </tr> </tbody> </table> <p>可以看到，最终x=3，y=2，破坏了一致性。</p> <h3 id="隔离级别">隔离级别</h3> <p>由于脏写破坏了事务的原子性，所以不管什么隔离级别都必须阻止这个问题，因此可以认为最弱的“读未提交RU”需要阻止脏写。</p> <h3 id="实现">实现</h3> <p>为了阻止脏写，事务需要给写操作加长锁，防止其他事务同时修改。</p> <h2 id="脏读-dirty-read">脏读 Dirty Read</h2> <p>一个事务对数据进行写操作后，还没有提交，就被另一个事务读取到。</p> <p>举例：假设x的初始值为100</p> <table> <thead> <tr> <th>时间</th> <th>事务A</th> <th>事务B</th> </tr> </thead> <tbody> <tr> <td>T1</td> <td>begin</td> <td>begin</td> </tr> <tr> <td>T2</td> <td>写x,x=200</td> <td> </td> </tr> <tr> <td>T3</td> <td> </td> <td>读x,x=200</td> </tr> <tr> <td>T4</td> <td>rollback</td> <td>…</td> </tr> </tbody> </table> <p>可以看到由于事务A回滚，事务B读取到的x=200变成了脏数据。</p> <h3 id="问题-1">问题</h3> <p>脏读会影响数据一致性。</p> <p>例如x=50，y=50，x给y转账40，要求转账前后都满足 x+y=100。</p> <table> <thead> <tr> <th>时间</th> <th>事务A</th> <th>事务B</th> </tr> </thead> <tbody> <tr> <td>T1</td> <td>begin</td> <td>begin</td> </tr> <tr> <td>T2</td> <td>写x,x=10</td> <td> </td> </tr> <tr> <td>T3</td> <td> </td> <td>读x,x=10</td> </tr> <tr> <td>T4</td> <td> </td> <td>读y,y=50</td> </tr> <tr> <td>T5</td> <td>写y,y=90</td> <td>commit</td> </tr> <tr> <td>T6</td> <td>commit</td> <td> </td> </tr> </tbody> </table> <p>可以看到事务B读取到的x和y不满足x+y=100，一致性被破坏。</p> <h3 id="隔离级别-1">隔离级别</h3> <p>读已提交RR，可以阻止该异相。</p> <h3 id="实现-1">实现</h3> <p>为了防止脏写，我们已经对写操作加了长锁，在此基础上，给读操作加上短锁即可避免脏读问题。 需要注意，这里还要给读操作加上短谓词锁，防止读操作在范围查询过程中读到了其他事务未提交的新增数据。</p> <h2 id="不可重复读-fuzzy-read--non-repeatable-read">不可重复读 Fuzzy Read / Non-repeatable Read</h2> <p>一个事务多次读取数据的过程中，数据被其他事务修改提交。（因为RC级别读数据加的是短锁，在两个短锁的间隙中数据有可能被其他事务修改）</p> <h3 id="问题-2">问题</h3> <p>例如：x初始值为1</p> <table> <thead> <tr> <th>时间</th> <th>事务A</th> <th>事务B</th> </tr> </thead> <tbody> <tr> <td>T1</td> <td>begin</td> <td>begin</td> </tr> <tr> <td>T2</td> <td>读x,x=1</td> <td> </td> </tr> <tr> <td>T3</td> <td> </td> <td>写x,x=2</td> </tr> <tr> <td>T4</td> <td> </td> <td>commit</td> </tr> <tr> <td>T5</td> <td>读x,x=2</td> <td> </td> </tr> <tr> <td>T6</td> <td>commit</td> <td> </td> </tr> </tbody> </table> <p>可以看到事务A两次读取x的值不一致，破坏了一致性。</p> <p>另外，即使没有重复读取某一个值，只要事务两次读取的值之间有一致性约束，就可能出现问题。</p> <p>我们还以脏读中转账的例子说明，新的执行序列如下表：</p> <table> <thead> <tr> <th>时间</th> <th>事务A</th> <th>事务B</th> </tr> </thead> <tbody> <tr> <td>T1</td> <td>begin</td> <td>begin</td> </tr> <tr> <td>T2</td> <td> </td> <td>读x,x=50</td> </tr> <tr> <td>T3</td> <td>写x,x=10</td> <td> </td> </tr> <tr> <td>T4</td> <td>写y,y=90</td> <td> </td> </tr> <tr> <td>T5</td> <td>commit</td> <td> </td> </tr> <tr> <td>T6</td> <td> </td> <td>读y,y=90</td> </tr> <tr> <td>T7</td> <td> </td> <td>commit</td> </tr> </tbody> </table> <p>可以看到，事务B读取的x和y不满足约束 x+y=100；</p> <h3 id="隔离级别-2">隔离级别</h3> <p>可重复读RR 阻止了事务修改其他事务正在读取的数据，即<code class="language-plaintext highlighter-rouge">不可重复读</code>这个异相。</p> <h3 id="实现-2">实现</h3> <p>在RC级别中，我们已经给写操作加了长锁，给读操作加了短锁（对象锁+谓词锁），为了阻止不可重复读的问题，需要给读操作中的记录加上长锁，因此可重复读RR级别的锁实现就是读操作中的记录加长锁（S锁），谓词锁加短锁（S锁），写操作加长锁（X锁）。</p> <h2 id="幻读-phantom-read">幻读 Phantom Read</h2> <p>一个事务通过查询条件读取数据集，另一个事务的写操作改变了匹配该条件的数据集（可能是插入了新数据，或者删除了匹配条件的数据，也可能是通过更新操作让其他操作也匹配了该条件）。</p> <h3 id="问题-3">问题</h3> <p>假如有如下执行序列：</p> <blockquote> <p>r1[P] — w2[insert x in P] — c2 — r1[P] Means Transaction_1 reads data set in P, then Transaction_2 insert a record in P, then Transaction_1 reads data set in P again.</p> </blockquote> <p>该序列会导致事务1两次读取数据集的结果不一致，破坏了一致性。</p> <h3 id="隔离级别-3">隔离级别</h3> <p>可串行化阻止了幻读异相的发生。</p> <h3 id="实现-3">实现</h3> <p>在 RR 级别中，我们已经给读操作加了长记录锁和短谓词锁，为了防止幻读，需要将谓词锁也改为长锁，在读取某条件时，将该条件锁定，防止其他事务的写入影响该条件。</p> <h2 id="丢失更新-lost-update">丢失更新 Lost Update</h2> <p>后面提到的三种异相，可能会比较陌生。</p> <p>丢失更新是指一个事务的写入被另一个已提交的事务覆盖（也称为第二类丢失更新，对照脏写）。</p> <h3 id="问题-4">问题</h3> <p>举例：两个事务修改计数器 c，让计数器加1。c 的初始值为1。</p> <table> <thead> <tr> <th>时间</th> <th>事务A</th> <th>事务B</th> </tr> </thead> <tbody> <tr> <td>T1</td> <td>begin</td> <td>begin</td> </tr> <tr> <td>T2</td> <td>读c,c=1</td> <td>读c,c=1</td> </tr> <tr> <td>T3</td> <td>写c,c=2</td> <td> </td> </tr> <tr> <td>T4</td> <td>commit</td> <td> </td> </tr> <tr> <td>T5</td> <td> </td> <td>写c,c=2</td> </tr> <tr> <td>T6</td> <td> </td> <td>commit</td> </tr> </tbody> </table> <p>可以发现，事务B提交后，计数器的值为2，事务A的提交丢失了。</p> <h3 id="隔离级别-4">隔离级别</h3> <p>分析上面的例子，我们发现问题出现在事务B读取c之后，事务A对c进行了修改，上面的可重复读RR级别可以阻止该异相。可重复读在读取的记录上加长锁，可以阻止其他事务在此期间修改数据。在上面的例子中，由于对c加了长读锁，两个事务的写操作都会相互等待对方的读锁释放，形成死锁，如果有死锁检测机制，事务B会自动回滚，不会出现丢失更新的现象。</p> <h2 id="读偏序-read-skew">读偏序 Read Skew</h2> <p>原本多个数据存在一致性的约束，读取却违反了该约束。</p> <h4 id="问题-5">问题</h4> <p>我们直接使用不可重复读的第二个例子，读偏序属于不可重复读的一种情况。</p> <blockquote> <p>r1[x] — w2[x] — w2[y] — c2 — r1[y] — c1 事务1的两次读取见，事务2修改了数据，导致事务1读取到的数据不一致。</p> </blockquote> <h3 id="隔离级别-5">隔离级别</h3> <p>从上面的例子可以看出，读偏序属于不可重复读的一种，因此可重复读RR级别可以阻止该异相。</p> <h2 id="写偏序-write-skew">写偏序 Write Skew</h2> <p>写操作违反了一致性约束。</p> <h3 id="问题-6">问题</h3> <p>第一个问题：假设x和y是一个人的两个信用卡账户，我们要求x + y不能小于0，而x或者y可以小于0，就是说你的一张信用卡可以是负的，但是全部加起来不能也是负的。</p> <p>下面事务A和事务B是两次并发的扣款，x初始值为20，y初始值为20。</p> <table> <thead> <tr> <th>时间</th> <th>事务A</th> <th>事务B</th> </tr> </thead> <tbody> <tr> <td>T1</td> <td>begin</td> <td>begin</td> </tr> <tr> <td>T2</td> <td>read,x=20,y=20</td> <td>read,x=20,y=20</td> </tr> <tr> <td>T3</td> <td>账户总额40,扣款30</td> <td> </td> </tr> <tr> <td>T4</td> <td>write,x=-10,y=20</td> <td> </td> </tr> <tr> <td>T5</td> <td> </td> <td>账户总额40,扣款30</td> </tr> <tr> <td>T6</td> <td> </td> <td>write,x=20,y=-10</td> </tr> <tr> <td>T7</td> <td>commit</td> <td> </td> </tr> <tr> <td>T8</td> <td> </td> <td>commit</td> </tr> </tbody> </table> <p>我们发现两个事务提交后，x+y=-20，违反了约束。这个是严格意义上的写偏序，还有由于幻读产生的写偏序。</p> <p>第二个问题：假设我们要做一个注册用户的功能，要求用户名唯一，并且没有给用户名加唯一索引，也就是说唯一性我们自己来保证。</p> <p>用户表已有用户名a，b，c，两个用户同时注册用户名d。</p> <table> <thead> <tr> <th>时间</th> <th>事务A</th> <th>事务B</th> </tr> </thead> <tbody> <tr> <td>T1</td> <td>begin</td> <td>begin</td> </tr> <tr> <td>T2</td> <td>读取所有用户:a,b,c</td> <td>读取所有用户:a,b,c</td> </tr> <tr> <td>T3</td> <td>发现没有d,插入d</td> <td> </td> </tr> <tr> <td>T4</td> <td>commit</td> <td> </td> </tr> <tr> <td>T5</td> <td> </td> <td>发现没有d,插入d</td> </tr> <tr> <td>T6</td> <td> </td> <td>commit</td> </tr> </tbody> </table> <p>两个事务提交之后，用户名d有了两个，违反了唯一性约束。</p> <p>这个问题是由于幻读引起的。</p> <h3 id="隔离级别-6">隔离级别</h3> <p>上面的两个例子，第一个是严格意义上的写偏序，可以通过可重复读RR阻止（写操作会被读锁阻塞），第二个是幻读引起的，本质上属于幻读问题，只有可串行化级别可以阻止（上面的例子中，由于有谓词锁的存在，事务A的写操作会被阻塞）。</p> <h2 id="隔离级别汇总">隔离级别汇总</h2> <p>从隔离级别可以阻止的异相角度：</p> <table> <thead> <tr> <th>Isolation Level</th> <th>P0 <br> Dirty Write</th> <th>P1 <br> Drity Read</th> <th>P2 <br> Fuzzy Read</th> <th>P3 <br> Phantom Read</th> <th>Lost Update</th> <th>Read Skew</th> <th>Write Skew</th> <th> </th> </tr> </thead> <tbody> <tr> <td>None</td> <td>✅</td> <td>✅</td> <td>✅</td> <td>✅</td> <td>✅</td> <td>✅</td> <td>✅</td> <td>✅</td> </tr> <tr> <td>ANSI READ UNCOMMITTED</td> <td>❌</td> <td>✅</td> <td>✅</td> <td>✅</td> <td>✅</td> <td>✅</td> <td>✅</td> <td>✅</td> </tr> <tr> <td>ANSI READ COMMITTED</td> <td>❌</td> <td>❌</td> <td>✅</td> <td>✅</td> <td>✅</td> <td>✅</td> <td>✅</td> <td>✅</td> </tr> <tr> <td>ANSI REPEATABLE READ</td> <td>❌</td> <td>❌</td> <td>❌</td> <td>✅</td> <td>✅</td> <td>❌</td> <td>❌</td> <td>❌</td> </tr> <tr> <td>ANOMALY SERIALIZABLE</td> <td>❌</td> <td>❌</td> <td>❌</td> <td>❌</td> <td>❌</td> <td>❌</td> <td>❌</td> <td>❌</td> </tr> </tbody> </table> <p>从锁的角度：</p> <table> <thead> <tr> <th>Isolation Level</th> <th>Read (Share Lock)</th> <th>Write (Mutex Lock)</th> </tr> </thead> <tbody> <tr> <td>None</td> <td>None</td> <td>None</td> </tr> <tr> <td>ANSI READ UNCOMMITTED</td> <td>None</td> <td>长锁</td> </tr> <tr> <td>ANSI READ COMMITTED</td> <td>记录锁加短锁<br>谓词锁加短锁</td> <td>长锁</td> </tr> <tr> <td>ANSI REPEATABLE READ</td> <td>记录锁加长锁<br>谓词锁加短锁</td> <td>长锁</td> </tr> <tr> <td>ANOMALY SERIALIZABLE</td> <td>记录锁加长锁<br>谓词锁加长锁</td> <td>长锁</td> </tr> </tbody> </table> <h1 id="总结">总结</h1> <p>本文整理了事务的相关概念，重点说明了事务的几种弱隔离级别以及基于锁的实现。频繁加锁势必会影响数据库的性能，因此很多数据库实际上使用的是多版本管理的方式，这就引出了另一种隔离级别：快照隔离，后面会单独介绍。</p> <p>本文参考了：</p> <ul> <li><a href="https://www.cnblogs.com/luojidong/p/14266590.html" rel="external nofollow noopener" target="_blank">MySQL事务101</a></li> <li><a href="https://catkang.github.io/2018/08/31/isolation-level.html" rel="external nofollow noopener" target="_blank">数据库事务隔离发展历史</a></li> <li><a href="https://vonng.github.io/ddia/#/ch7" rel="external nofollow noopener" target="_blank">DDIA第七章事务</a></li> <li><a href="https://www.qtmuniao.com/2022/07/07/db-isolation/" rel="external nofollow noopener" target="_blank">步步为营 剖析事务中最难的 —— 隔离性</a></li> </ul> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography><div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"wzm001/wzm001.github.io","data-repo-id":"R_kgDOG5N29g","data-category":"Announcements","data-category-id":"DIC_kwDOG5N29s4CUo0g","data-mapping":"title","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Jimmy Wu. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>