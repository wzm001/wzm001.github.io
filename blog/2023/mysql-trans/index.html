<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>MySQL 事务支持 | Jimmy Wu</title> <meta name="author" content="Jimmy Wu"> <meta name="description" content="MySQL 的事务支持细节"> <meta name="keywords" content="Java, 后端, Software Developer"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/icon.png#%20the%20emoji%20used%20as%20the%20favicon%20(alternatively,%20provide%20image%20name%20in%20/assets/img/)"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://wzm001.github.io//blog/2023/mysql-trans/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Jimmy Wu</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">关于我</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">博客<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">项目</a> </li> <li class="nav-item "> <a class="nav-link" href="/assets/pdf/cv.pdf">简历</a> </li> <li class="nav-item "> <a class="nav-link" href="/assets/pdf/ecv.pdf">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">MySQL 事务支持</h1> <p class="post-meta">March 11, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/mysql"> <i class="fas fa-hashtag fa-sm"></i> MySQL</a>   <a href="/blog/tag/%E4%BA%8B%E5%8A%A1"> <i class="fas fa-hashtag fa-sm"></i> 事务</a>   <a href="/blog/tag/innodb"> <i class="fas fa-hashtag fa-sm"></i> InnoDB</a>     ·   <a href="/blog/category/database"> <i class="fas fa-tag fa-sm"></i> Database</a>   <a href="/blog/category/mysql"> <i class="fas fa-tag fa-sm"></i> MySQL</a>   </p> </header> <article class="post-content"> <p>前面几篇整理了事务的一些通用概念，这一篇梳理一下 MySQL 是如何支持事务的。本篇主要梳理 InnoDB 的实现逻辑，不包含其他存储引擎。</p> <h1 id="innodb-的锁机制">InnoDB 的锁机制</h1> <h2 id="共享锁和排它锁">共享锁和排它锁</h2> <p>InnoDB 实现了行级别和表级别的共享锁 (S) 和排它锁 (X)。持有共享锁的事务可以读取对应的行，持有排它锁的事务可以修改或删除该行。</p> <p>共享锁和排它锁的兼容性：</p> <table> <thead> <tr> <th style="text-align: center">事务锁</th> <th style="text-align: center">S</th> <th style="text-align: center">X</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">S</td> <td style="text-align: center">Compatible</td> <td style="text-align: center">Conflict</td> </tr> <tr> <td style="text-align: center">X</td> <td style="text-align: center">Conflict</td> <td style="text-align: center">Conflict</td> </tr> </tbody> </table> <h2 id="意向锁">意向锁</h2> <p>上面介绍了 InnoDB 在行级别的共享锁和排它锁，InnoDB 还有表级别的共享锁和排它锁。InnoDB 同时支持多粒度锁定，允许表锁和行锁并存。例如 <code class="language-plaintext highlighter-rouge">LOCK TABLE ... WRITE</code> 之类的语句在指定的表上获取排它锁。</p> <p>考虑这样一个场景：事务 A 在表 <code class="language-plaintext highlighter-rouge">test</code> 中的某行加了 S 锁，事务 B 需要在 <code class="language-plaintext highlighter-rouge">test</code> 整个表上加 X 锁，此时事务 B 需要遍历表中的每一行，判断该行是否被锁定，效率十分低下。因此 InnoDB 添加了意向锁，<em>它是表级别的锁，用来标记当前表中是否有某些行被锁定或即将被锁定</em>。</p> <p>有两种类型的意向锁：</p> <ul> <li>意向共享锁（IS）：表示事务打算在表中某行上加共享锁；</li> <li>意向排它锁（IX）：表示事务打算在表中某行上加排它锁；</li> </ul> <p>设置行锁前，需要先获取到对应的意向锁。例如 <code class="language-plaintext highlighter-rouge">SELECT ... FOR SHARE</code> 语句会在表上获取 IS 锁，<code class="language-plaintext highlighter-rouge">SELECT ... FOR UPDATE</code> 会在表上获取 IX 锁。</p> <p>意向锁的协议如下：</p> <ul> <li>在事务可以获取表中某行的共享锁之前，必须先获取到表上的 IS 锁或 IX 锁；</li> <li>在事务可以获取表中某行的排它锁之前，必须先获取到表上的 IX 锁；</li> </ul> <p>下表整理了 <em>表级锁</em> 的兼容性： | | X | IX | S | IS | |–|–|–|–|–| | X | Conflict| Conflict | Conflict | Conflict | | IX | Conflict | Compatible | Conflict | Compatible | | S | Conflict | Conflict | Compatible | Compatible | | IS | Conflict | Compatible | Compatible | Compatible |</p> <p>如果锁冲突，当前事务需要被阻塞，直到等待的锁资源被释放出来。</p> <p>意向锁只会阻塞表锁，不会阻塞其他意向锁或行锁，意向锁的主要目的是为了标记当前表中存在（或即将出现）行锁。</p> <h2 id="记录锁-record-locks">记录锁 Record Locks</h2> <p>记录锁是索引记录上的锁。对于 InnoDB 而言，指的就是聚簇索引上的锁，也就是行锁。</p> <h2 id="间隙锁-gap-locks">间隙锁 Gap Locks</h2> <p>间隙锁是索引记录之间的间隙上的锁。或者是第一条索引记录之前的间隙以及最后一条索引记录之后的间隙。例如：</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">c1</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">c1</span> <span class="k">between</span> <span class="mi">10</span> <span class="k">and</span> <span class="mi">20</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>
</code></pre></div></div> <p>这条语句会获取 10～20 的间隙锁。防止其他事务插入 <code class="language-plaintext highlighter-rouge">c1 = 15</code> 的记录。</p> <p>间隙锁锁定的是行之间的间隙，无论间隙内是否有真实的行存在。</p> <p>对于语句：</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">child</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</code></pre></div></div> <p>如果 <code class="language-plaintext highlighter-rouge">id</code> 列是主键或者唯一索引，则该语句只加行锁。如果 <code class="language-plaintext highlighter-rouge">id</code> 列没有索引或只有非唯一性索引，则该语句会锁定前面的间隙（防止幻读）。</p> <p>另外，间隙锁不会互斥，不同事务可以在相同的间隙上持有间隙锁。</p> <p>如果事务隔离级别调整为 RC，MySQL 会禁用间隙锁。</p> <h2 id="临键锁-next-key-locks">临键锁 Next-key Locks</h2> <p>临键锁是 <em>索引记录上的记录锁</em> 加上 <em>索引记录之前的间隙锁</em>。临键锁可以防止幻读。在 MySQL 默认的 RR 隔离级别中，InnoDB 使用临键锁进行搜索和索引扫描。（只限与没有索引和非唯一索引的列，唯一索引列使用记录锁）</p> <h2 id="插入意向锁-insert-intention-locks">插入意向锁 Insert Intention Locks</h2> <p>插入意向锁是一种在行插入之前由 <code class="language-plaintext highlighter-rouge">insert</code> 操作设置的间隙锁，这个锁表示插入的意图。</p> <h2 id="自增锁-auto-inc-locks">自增锁 AUTO-INC Locks</h2> <p>自增锁是一种特殊的<em>表级别</em>的锁，由插入到具有 <code class="language-plaintext highlighter-rouge">AUTO_INCREMENT</code> 列的表中的事务获取。目的是为了防止并发插入自增列冲突的情况。</p> <h1 id="innodb-的事务隔离级别">InnoDB 的事务隔离级别</h1> <p>InnoDB 支持标准的四种隔离级别。</p> <h2 id="可重复读-rr">可重复读 RR</h2> <p>InnoDB 使用最多的隔离级别，也是默认的隔离级别。可重复读使用快照支持<em>一致性读取</em>。当事务开启时建立快照，整个事务过程中读取的数据都是一致的。</p> <p>对于<em>锁定读取</em>（<code class="language-plaintext highlighter-rouge">SELECT ... FOR UPDATE</code> 或 <code class="language-plaintext highlighter-rouge">SELECT ... FOR SHARE</code>）和 <code class="language-plaintext highlighter-rouge">UPDATE</code> 以及 <code class="language-plaintext highlighter-rouge">DELETE</code> 语句，锁定范围取决于搜索条件是否使用了唯一索引。</p> <ul> <li>如果搜索条件使用了唯一索引，InnoDB 只锁定找到的索引记录，而不锁定其之前的间隙；</li> <li>如果不是唯一索引搜索，InnoDB 锁定扫描的索引范围，使用间隙锁或临键锁来阻止其他事务插入到该范围覆盖的间隙中。</li> </ul> <h2 id="读已提交-rc">读已提交 RC</h2> <p>读已提交级别的一致性读取，会在事务中使用多个快照，每次读取的数据都是最新提交的一致性快照。</p> <p>对于锁定读取或更新，InnoDB 只锁定索引记录，不锁定它们之间的间隙。</p> <h1 id="一致性非阻塞读取">一致性非阻塞读取</h1> <p>InnoDB 使用 MVCC 机制支持一致性非阻塞读取，因此事务中正常查询是不需要加锁的。</p> <p>例如在默认的 RR 隔离级别下：</p> <p>假设测试表 <code class="language-plaintext highlighter-rouge">employee</code> 有如下数据：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; select * from employee;
+----+----------+---------+---------+
| id | emp_name | emp_age | address |
+----+----------+---------+---------+
|  3 | Gike     |      19 | beijing |
|  1 | Jimmy    |      21 | beijing |
|  2 | Jone     |      20 | hk      |
+----+----------+---------+---------+
3 rows in set (0.00 sec)
</code></pre></div></div> <p>开启事务A，在事务中查询年龄大于20岁的员工：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from employee where emp_age &gt; 20;
+----+----------+---------+---------+
| id | emp_name | emp_age | address |
+----+----------+---------+---------+
|  1 | Jimmy    |      21 | beijing |
+----+----------+---------+---------+
1 row in set (0.01 sec)
</code></pre></div></div> <p>开启事务B，在事务中修改 Jone 的年龄为 22 岁，并提交事务：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; update employee set emp_age = 22 where emp_name = 'Jone';
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&gt; commit;
Query OK, 0 rows affected (0.00 sec)
</code></pre></div></div> <p>此时事务A还没有提交，再次执行相同的查询，发现结果仍然只有一条，新的数据没有查到：(前提是在 RR 隔离级别下)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; select * from employee where emp_age &gt; 20;
+----+----------+---------+---------+
| id | emp_name | emp_age | address |
+----+----------+---------+---------+
|  1 | Jimmy    |      21 | beijing |
+----+----------+---------+---------+
1 row in set (0.00 sec)
</code></pre></div></div> <p>直到事务A提交之后再次查询，才能看到最新的数据：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; commit;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from employee where emp_age &gt; 20;
+----+----------+---------+---------+
| id | emp_name | emp_age | address |
+----+----------+---------+---------+
|  1 | Jimmy    |      21 | beijing |
|  2 | Jone     |      22 | hk      |
+----+----------+---------+---------+
2 rows in set (0.00 sec)
</code></pre></div></div> <p>这里需要注意：<em>一致性快照读取只针对读取操作，更新和删除操作不会走快照</em>。因此其他事务提交的内容有可能被当前事务修改。我们还以上面的表为例说明，现在的初始数据为：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; select * from employee;
+----+----------+---------+---------+
| id | emp_name | emp_age | address |
+----+----------+---------+---------+
|  3 | Gike     |      19 | beijing |
|  1 | Jimmy    |      21 | beijing |
|  2 | Jone     |      22 | hk      |
+----+----------+---------+---------+
3 rows in set (0.00 sec)
</code></pre></div></div> <p>开启事务A，查询年龄小于 20 岁的员工：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from employee where emp_age &gt; 20;
+----+----------+---------+---------+
| id | emp_name | emp_age | address |
+----+----------+---------+---------+
|  3 | Gike     |      19 | beijing |
+----+----------+---------+---------+
1 rows in set (0.00 sec)
</code></pre></div></div> <p>开启事务B，修改 Jone 的年龄为 18 岁，并提交事务：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; update employee set emp_age = 18 where emp_name = 'Jone';
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&gt; commit;
Query OK, 0 rows affected (0.00 sec)
</code></pre></div></div> <p>在事务A中删除年龄小于 20 岁的员工：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; delete from employee where emp_age &lt; 20;
Query OK, 2 rows affected (0.01 sec)
</code></pre></div></div> <p>我们注意到这条语句删除了两条记录，虽然在这个事务中查询年龄小于 20 岁的员工记录时只查到了一条，但删除的时候却删除了两条，因为还有一条记录是事务 B 提交的。</p> <p>提交事务 A 后再次查询表中的记录，发现只剩下一条了：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; commit;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from employee;
+----+----------+---------+---------+
| id | emp_name | emp_age | address |
+----+----------+---------+---------+
|  1 | Jimmy    |      21 | beijing |
+----+----------+---------+---------+
1 row in set (0.00 sec)
</code></pre></div></div> <p>对于 <code class="language-plaintext highlighter-rouge">INSERT INTO ... SELECT</code>，<code class="language-plaintext highlighter-rouge">UPDATE ... (SELECT)</code> 和 <code class="language-plaintext highlighter-rouge">CREATE TABLE ... SELECT</code> 语句的 SELECT 部分，如果没有指定 <code class="language-plaintext highlighter-rouge">FOR UPDATE</code> 或 <code class="language-plaintext highlighter-rouge">FOR SHARE</code>，默认情况下 InnoDB 会对这些语句使用更强的锁，SELECT 部分的行为类似于 RC 级别的查询，每次执行都会读取新快照。</p> <h1 id="锁定读取">锁定读取</h1> <p>在上面的第二个例子中，我们看到如果当前事务查询并修改某些数据，其他事务有可能会破坏该操作。为了避免此类问题，InnoDB 提供了锁定读取操作：<code class="language-plaintext highlighter-rouge">SELECT ... FOR SHARE</code> 和 <code class="language-plaintext highlighter-rouge">SELECT ... FOR UPDATE</code>。</p> <p>我们还回到上面的例子中，此时 <code class="language-plaintext highlighter-rouge">employee</code> 表中的初始数据为：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; select * from employee;
+----+----------+---------+---------+
| id | emp_name | emp_age | address |
+----+----------+---------+---------+
|  1 | Jimmy    |      21 | beijing |
+----+----------+---------+---------+
1 row in set (0.00 sec)
</code></pre></div></div> <p>开启事务 A，先查询年龄大于 20 岁的员工，使用锁定读取：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from employee where emp_age &gt; 20 for share;
+----+----------+---------+---------+
| id | emp_name | emp_age | address |
+----+----------+---------+---------+
|  1 | Jimmy    |      21 | beijing |
+----+----------+---------+---------+
1 row in set (0.01 sec)
</code></pre></div></div> <p>开启事务 B，先做一次同样的查询，因为事务 A 使用的是共享锁，所以事务 B 此时也是可以查询的：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from employee where emp_age &gt; 20 for share;
+----+----------+---------+---------+
| id | emp_name | emp_age | address |
+----+----------+---------+---------+
|  1 | Jimmy    |      21 | beijing |
+----+----------+---------+---------+
1 row in set (0.00 sec)
</code></pre></div></div> <p>事务 B 修改该记录的地址为 hk：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; update employee set address = 'hk' where id = 1;
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
</code></pre></div></div> <p>发现事务 B 的修改语句被阻塞了一段时间后报错退出。</p> <p>提交事务 A 后，事务 B 再次执行该语句，发现可以执行了：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; update employee set address = 'hk' where id = 1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&gt; commit;
Query OK, 0 rows affected (0.01 sec)
</code></pre></div></div> <h1 id="innodb-语句和锁的关系">InnoDB 语句和锁的关系</h1> <p>锁定读取、更新、删除操作都会在扫描的每一条索引记录上添加临键锁，无论记录是否满足 <code class="language-plaintext highlighter-rouge">where</code> 条件。 如果在搜索条件中使用了二级索引，并且要设置的记录锁是独占的，InnoDB 也会键锁对应的聚簇索引并加锁。 如果搜索条件没有用到索引，那么必须通过全表扫描来处理，这样表中的每一行都会被锁定，因此会阻塞其他事务的插入操作。对查询条件创建必要的索引很重要。</p> <p>下面具体分析不同语句的加锁情况：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">SELECT ... FROM</code> 语句是一致性读取，通过 MVCC 实现，不需要加锁。（除非隔离级别是可串行化）</li> <li>锁定读，如果使用了唯一索引，会首先在扫描的行上加锁，然后把不符合查询条件的行上的锁释放掉。但释放锁的操作可能不是立即发生的，最晚要等到事务提交后才释放。</li> <li>锁定读、更新、删除操作的加锁策略，取决于语句是使用的是唯一索引或者范围查询： <ul> <li>如果使用的是唯一索引的唯一查询，例如 <code class="language-plaintext highlighter-rouge">id = 1</code>，则只锁定找到的索引记录，不锁定记录之前的间隙；</li> <li>如果不满足上一个条件，则锁定使用临键锁锁定记录和记录前的间隙；</li> </ul> </li> <li> <code class="language-plaintext highlighter-rouge">UPDATE ... WHERE ...</code> 语句修改聚簇索引时，会对关联的二级索引进行隐式锁定。当插入新的二级索引之前或执行重复检查扫描时，<code class="language-plaintext highlighter-rouge">UPDATE</code> 操作还会对受影响的二级索引记录使用共享锁；</li> <li> <code class="language-plaintext highlighter-rouge">INSERT</code> 语句会在插入的行上设置排它锁。这个锁是记录锁，不是临键锁；</li> <li> <code class="language-plaintext highlighter-rouge">INSERT</code> 操作之前会设置插入意向锁，这是一个间隙锁，多个事务之间可以同时锁定同一个间隙；</li> <li>如果检测到重复键错误，会在重复索引记录上设置共享锁；我们还以上面的 <code class="language-plaintext highlighter-rouge">employee</code> 表为例，假设有两个事务都执行如下语句： <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>start transaction;
insert into employee values (2, 'Jack', 23, 'Shanghai');
</code></pre></div> </div> <p>我们发现，第一个事务执行成功了，第二个事务阻塞了。因为第二个事务检测到重复键错误，会在该重复键上添加共享锁。但第一个事务还没有提交，所以此时重复键上还有第一个事务设置的排它锁，因此第二个事务阻塞了，直到第一个事务提交或回滚，释放了排它锁，第二个事务才能获取到共享锁继续往下执行。 还是上面的语句，如果有三个事务同时执行，首先事务一执行成功了，事务二和事务三都被阻塞（等待重复键的共享锁），当事务一回滚后，事务二和事务三都获取到了共享锁，又因为都是插入操作，还要获取到排它锁，这时候就发生死锁了。原因是事务二和事务三都在等待对方释放共享锁后获得排它锁。</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>mysql&gt; insert into employee values (2, 'Jack', 23, 'Shanghai');
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
</code></pre></div> </div> </li> <li> <code class="language-plaintext highlighter-rouge">INSERT ... ON DUPLICATE KEY UPDATE</code> 语句和 <code class="language-plaintext highlighter-rouge">INSERT</code> 语句的区别是，当发生重复键错误时，<code class="language-plaintext highlighter-rouge">INSERT</code> 语句设置的是共享锁，而 <code class="language-plaintext highlighter-rouge">INSERT ... ON DUPLICATE KEY UPDATE</code> 设置的是排它锁。对于重复的主键，设置独占的记录锁，对于重复的唯一索引，设置独占的临键锁；</li> <li> <a href="https://dev.mysql.com/doc/refman/8.0/en/replace.html" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">REPLACE</code></a> 语句如果没有重复键错误，和 <code class="language-plaintext highlighter-rouge">INSERT</code> 语句一样完成，如果有重复键错误，将设置排它的临键锁在要替换的行上；</li> <li> <code class="language-plaintext highlighter-rouge">INSERT INTO t SELECT ... FROM s WHERE ...</code> 语句，会在插入到 <code class="language-plaintext highlighter-rouge">t</code> 表上的每一行设置排它的记录锁，这是 <code class="language-plaintext highlighter-rouge">INSERT</code> 语句的特性。此时如果事务隔离级别为 RC，InnoDB 会在 <code class="language-plaintext highlighter-rouge">s</code> 表上执行一致性快照读取，不会加锁。如果是其他的隔离级别，InnoDB 则会在 <code class="language-plaintext highlighter-rouge">s</code> 表上扫描的行上设置共享临键锁，这是 InnoDB 的二进制日志机制要求的；</li> <li> <code class="language-plaintext highlighter-rouge">CREATE TABLE ... SELECT ...</code> 语句和上面的 <code class="language-plaintext highlighter-rouge">INSERT ... SELECT</code> 语句一样，会根据隔离级别设置共享临键锁或者不加锁；</li> <li> <code class="language-plaintext highlighter-rouge">REPLACE INTO t SELECT ... FROM s WHERE ...</code> 和 <code class="language-plaintext highlighter-rouge">UPDATE t ... WHERE col IN (SELECT ... FROM s WHERE ...)</code> 语句中的 <code class="language-plaintext highlighter-rouge">SELECT</code> 操作，会对表 <code class="language-plaintext highlighter-rouge">s</code> 中扫描的行添加共享的临键锁；</li> <li> <code class="language-plaintext highlighter-rouge">AUTO_INCREMENT</code> 列，InnoDB 会在列关联的索引末尾设置排它锁。如果 <code class="language-plaintext highlighter-rouge">innodb_autoinc_lock_mode = 0</code> ，InnoDB 会使用 <code class="language-plaintext highlighter-rouge">AUTO_INC</code> 表锁定模式，在访问自动递增计数器时获取表锁并保持到当前 SQL 语句结束（不是事务结束）。当持有 <code class="language-plaintext highlighter-rouge">AUTO_INC</code> 表锁时，其他事务无法执行插入操作。</li> <li>如果表上设置了外键约束，则任何需要检查约束条件的插入、更新、删除操作都需要在扫描的行上添加共享记录锁。在约束检查失败的情况下也会添加这些锁。</li> <li> <code class="language-plaintext highlighter-rouge">LOCK TABLES</code> 语句会设置表锁，但这些锁是在 InnoDB 之上的 MySQL 层设置的，InnoDB 如果在 <code class="language-plaintext highlighter-rouge">innodb_table_locks = 1（默认值）</code> 且 <code class="language-plaintext highlighter-rouge">autocommit = 0</code> 时知道表锁的存在，MySQL 层也知道 InnoDB 的行锁。否则在其他情况下，InnoDB 的死锁检测无法检测到涉及此类表锁的死锁。</li> <li>在 <code class="language-plaintext highlighter-rouge">innodb_table_locks = 1（默认值）</code> 的情况下，<code class="language-plaintext highlighter-rouge">LOCK TABLES</code> 语句会在表上获取两中表锁，一个是 MySQL 层的表锁，另一个是 InnoDB 层的表锁。</li> <li>不能在事务执行期间锁定其他表，因为 <code class="language-plaintext highlighter-rouge">LOCK TABLES</code> 语句隐式执行了 <code class="language-plaintext highlighter-rouge">COMMIT</code> 和 <code class="language-plaintext highlighter-rouge">UNLOCK TABLES</code>。</li> </ul> <h1 id="总结">总结</h1> <p>参考:</p> <ul> <li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html" rel="external nofollow noopener" target="_blank">InnoDB Locking</a></li> <li> </li> </ul> </article><div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"wzm001/wzm001.github.io","data-repo-id":"R_kgDOG5N29g","data-category":"Announcements","data-category-id":"DIC_kwDOG5N29s4CUo0g","data-mapping":"title","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Jimmy Wu. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>