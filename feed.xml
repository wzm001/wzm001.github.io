<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="cn"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://wzm001.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://wzm001.github.io//" rel="alternate" type="text/html" hreflang="cn"/><updated>2023-06-07T15:35:51+00:00</updated><id>https://wzm001.github.io//feed.xml</id><title type="html">Jimmy Wu</title><subtitle>人生在勤，不索何获 </subtitle><entry><title type="html">Spring 容器的实现原理</title><link href="https://wzm001.github.io//blog/2023/spring-ioc/" rel="alternate" type="text/html" title="Spring 容器的实现原理"/><published>2023-05-19T02:00:00+00:00</published><updated>2023-05-19T02:00:00+00:00</updated><id>https://wzm001.github.io//blog/2023/spring-ioc</id><content type="html" xml:base="https://wzm001.github.io//blog/2023/spring-ioc/"><![CDATA[<p>Spring 是后端研发最常用的框架，而 IOC 容器则是 Spring 框架中使用最多的功能，也是 Spring 所有功能的基础。今天简单梳理一下 Spring 容器的一些实现原理，网上有很多资料对 Spring 容器的说明陷入了细节的纠缠中，没能从全局的角度理解容器。我尝试按照自己的理解说明一下。</p> <h1 id="什么是容器">什么是容器？</h1> <p>首先我们需要明确，Spring 的容器究竟是什么概念。从应用层面看，我们可以把 Spring 提供的 <code class="language-plaintext highlighter-rouge">ApplicationContext</code> 接口的具体实现当作容器的实例。因为我们在代码中经常这样使用：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Object</span> <span class="n">bean</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"beanName"</span><span class="o">);</span>
</code></pre></div></div> <p>通过名称获取容器中对应的 bean。这种用法让你想到了 java 中的什么 API ？是不是跟集合的使用有些类似？</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">objMap</span><span class="o">;</span>
<span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">objMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"objName"</span><span class="o">);</span>
</code></pre></div></div> <p>那么，Spring 底层是不是也是用 Map 来实现容器的功能呢？我们可以看一下对应的代码实现。无论是基于注解的 <code class="language-plaintext highlighter-rouge">AnnotationConfigApplicationContext</code> 或者基于 XML 配置文件的 <code class="language-plaintext highlighter-rouge">ClassPathXmlApplicationContext</code>，两者的 <code class="language-plaintext highlighter-rouge">getBean</code> 方法都继承自 <code class="language-plaintext highlighter-rouge">AbstractApplicationContext</code>：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>  
<span class="kd">public</span> <span class="nc">Object</span> <span class="nf">getBean</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">BeansException</span> <span class="o">{</span>  
   <span class="n">assertBeanFactoryActive</span><span class="o">();</span>  
   <span class="k">return</span> <span class="nf">getBeanFactory</span><span class="o">().</span><span class="na">getBean</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>  
<span class="o">}</span>
</code></pre></div></div> <p>可以看到，获取 bean 对象的具体操作委托给了 <code class="language-plaintext highlighter-rouge">BeanFactory</code> 对象。<code class="language-plaintext highlighter-rouge">BeanFactory</code> 又是什么组件？它和 <code class="language-plaintext highlighter-rouge">ApplicationContext</code> 的关系是什么？</p> <p>我们首先了解一下这两个接口整体上的继承关系：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/ApplicationContext-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/ApplicationContext-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/ApplicationContext-1400.webp"/> <img src="/assets/img/ApplicationContext.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> BeanFactory 和 ApplicationContext 的继承关系 </div> <p>具体的细节这里不展开，只简单介绍一下接口的大概作用：</p> <ul> <li>BeanFactory 是支持 IOC 容器的顶级接口，它提供了通过名称获取 bean 对象的基本操作。</li> <li>AliasRegistry 及其子接口提供了向容器注册 bean 对象的描述对象（BeanDefinition）的操作。</li> <li>SingletonBeanRegistry 提供了向容器注册 bean 对象的操作。</li> <li>ApplicationContext 是对 BeanFactory 做的扩展。它在 IOC 容器的基础上提供了国际化、配置初始化、容器继承等功能，作为应用上下文使用，是业务代码和框架进行交互的桥梁。</li> </ul> <p>这里我们抛开其他细节，看一下 <code class="language-plaintext highlighter-rouge">BeanFactory</code> 的默认实现类 <code class="language-plaintext highlighter-rouge">DefaultListableBeanFactory</code> 是如何支持通过名称获取 bean 对象的：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>  
<span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">getBean</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">requiredType</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">Object</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">BeansException</span> <span class="o">{</span>  
   <span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">requiredType</span><span class="o">,</span> <span class="s">"Required type must not be null"</span><span class="o">);</span>  
   <span class="nc">Object</span> <span class="n">resolved</span> <span class="o">=</span> <span class="n">resolveBean</span><span class="o">(</span><span class="nc">ResolvableType</span><span class="o">.</span><span class="na">forRawClass</span><span class="o">(</span><span class="n">requiredType</span><span class="o">),</span> <span class="n">args</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>  
   <span class="k">if</span> <span class="o">(</span><span class="n">resolved</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>  
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoSuchBeanDefinitionException</span><span class="o">(</span><span class="n">requiredType</span><span class="o">);</span>  
   <span class="o">}</span>  
   <span class="k">return</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span> <span class="n">resolved</span><span class="o">;</span>  
<span class="o">}</span>
</code></pre></div></div> <p>这个方法进一步调用了 <code class="language-plaintext highlighter-rouge">resolveBean</code> 方法：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">resolveBean</span><span class="o">(</span><span class="nc">ResolvableType</span> <span class="n">requiredType</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">nonUniqueAsNull</span><span class="o">)</span> <span class="o">{</span> 
    <span class="c1">// 先从当前容器中获取</span>
   <span class="nc">NamedBeanHolder</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">namedBean</span> <span class="o">=</span> <span class="n">resolveNamedBean</span><span class="o">(</span><span class="n">requiredType</span><span class="o">,</span> <span class="n">args</span><span class="o">,</span> <span class="n">nonUniqueAsNull</span><span class="o">);</span>  
   <span class="k">if</span> <span class="o">(</span><span class="n">namedBean</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>  
      <span class="k">return</span> <span class="n">namedBean</span><span class="o">.</span><span class="na">getBeanInstance</span><span class="o">();</span>  
   <span class="o">}</span>  
   <span class="c1">// 如果找不到，就从父容器中获取</span>
   <span class="c1">// ......</span>
<span class="o">}</span>
</code></pre></div></div> <p>在 <code class="language-plaintext highlighter-rouge">resolveNamedBean</code> 方法中，首先解析 bean 对象的名称，然后调用了 <code class="language-plaintext highlighter-rouge">AbstractBeanFactory</code> 中的 <code class="language-plaintext highlighter-rouge">getBean(String name)</code> 方法：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>  
<span class="kd">public</span> <span class="nc">Object</span> <span class="nf">getBean</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">BeansException</span> <span class="o">{</span>  
   <span class="k">return</span> <span class="nf">doGetBean</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>  
<span class="o">}</span>
</code></pre></div></div> <p>方法 <code class="language-plaintext highlighter-rouge">doGetBean</code> 是初始化 bean 对象的核心方法，它会初始化对应的 bean 对象，以及对象的依赖。这里的逻辑比较复杂，我们只看获取对象的部分</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">doGetBean</span><span class="o">(</span>  
      <span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">requiredType</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">typeCheckOnly</span><span class="o">)</span>  
      <span class="kd">throws</span> <span class="nc">BeansException</span> <span class="o">{</span>  
  
   <span class="nc">String</span> <span class="n">beanName</span> <span class="o">=</span> <span class="n">transformedBeanName</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>  
   <span class="nc">Object</span> <span class="n">beanInstance</span><span class="o">;</span>  
  
   <span class="c1">// Eagerly check singleton cache for manually registered singletons.  </span>
   <span class="nc">Object</span> <span class="n">sharedInstance</span> <span class="o">=</span> <span class="n">getSingleton</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
   <span class="c1">// ......</span>
<span class="o">}</span>
</code></pre></div></div> <p>再查看 <code class="language-plaintext highlighter-rouge">getSingleton(String name)</code> 方法，这个方法定义在 <code class="language-plaintext highlighter-rouge">AbstractBeanFactory</code> 的父类 <code class="language-plaintext highlighter-rouge">DefaultSingletonBeanRegistry</code> 中，最终我们会发现单例的 bean 对象放在这里：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** Cache of singleton objects: bean name to bean instance. */</span>  
<span class="kd">private</span> <span class="kd">final</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">singletonObjects</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ConcurrentHashMap</span><span class="o">&lt;&gt;(</span><span class="mi">256</span><span class="o">);</span>
</code></pre></div></div> <p>可以看到，Spring 底层确实是通过 Map 来支持对象的检索的，key 就是 bean 的名称，value 就是对应的 bean 对象。</p> <h1 id="spring-容器如何初始化">Spring 容器如何初始化</h1> <p>这里分析一下 <code class="language-plaintext highlighter-rouge">ApplicationContext</code> 的初始化。容器初始化的核心方法是 <code class="language-plaintext highlighter-rouge">AbstractApplicationContext.refresh()</code> 。</p>]]></content><author><name></name></author><category term="框架"/><category term="Java"/><category term="Spring"/><summary type="html"><![CDATA[Spring 容器的实现原理]]></summary></entry><entry><title type="html">关于简历优化的一些心得</title><link href="https://wzm001.github.io//blog/2023/resume/" rel="alternate" type="text/html" title="关于简历优化的一些心得"/><published>2023-05-06T07:45:16+00:00</published><updated>2023-05-06T07:45:16+00:00</updated><id>https://wzm001.github.io//blog/2023/resume</id><content type="html" xml:base="https://wzm001.github.io//blog/2023/resume/"><![CDATA[<p>简历是面试的敲门砖，也是体现个人竞争力的名片。简历的作用是用有限的篇幅，体现自己的优势和竞争力，让面试官和 HR 能快速抓住重点，判断是否和应聘的职位匹配。</p> <p>从整体上看，好的简历篇幅不宜过长，2～3 页为宜，太长的话没有重点。</p> <p>另外，简历模版尽量简单整洁一些， 不要太花哨。除非你投的是设计相关的职位。</p> <p>格式一定使用 PDF，其他格式在查看的时候容易出问题。</p> <p>文件名也需要注意，最好以 <code class="language-plaintext highlighter-rouge">姓名_[学历（可选）]_岗位_[手机号（可选）]</code> 的格式，学历也可以替换为工作年限，主要就是能展示出一些自己的基本信息。</p> <h1 id="个人基本信息">个人基本信息</h1> <p>基本信息放在简历头部，包括姓名、联系方式、工作年限、期望薪资等内容，如果有个人博客和网站，也可以加上。如果 github 有活跃的记录，可以加上，如果什么都没有，就别写了😂。</p> <h1 id="专业技能">专业技能</h1> <p>可以同时写上技能和掌握程度，也可以只列出技能名称，注意单词拼写正确。技能可以按照大分类写，例如：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>开发技能：Java，JVM，多线程，设计模式 ...
数据存储：MySQL，Redis，ES ....
</code></pre></div></div> <p>这种写法比较简洁，个人推荐这种。</p> <h1 id="工作经历">工作经历</h1> <p>工作经历最好能列出你在公司中主要负责的事项，注意不是项目经历，例如</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 配合产品做技术调研，评估实现方案；
2. 负责公司xxx项目的开发维护；
3. ......
</code></pre></div></div> <p>在每一段工作经历上都列出自己的工作内容，最好能加上工作对应的成果，显得有说服力。</p> <h1 id="教育经历">教育经历</h1> <p>这个简单列出来即可。</p> <h1 id="项目经历重要">项目经历【重要】</h1> <p>项目经历是程序员简历中最重要的部分，这部分能体现你的工作能力，也能直观体现你和该职位的匹配程度。HR 和面试官最关注这部分内容。</p> <p>项目经历主要包括四部分内容：项目名称、项目描述、涉及的技术以及本人负责的内容。</p> <p>网上有人说用 STAR 法则来描述，但这么写内容有些多，可以简化成 “用 xx + yy 技术，实现了 xx 效果”，这个效果最好有数据支撑，如果没有，看看能不能用一些专业术语来描述，比如流量削峰、稳定性、幂等之类的。当然如果没有具体数据，也可以大概评估一下。</p> <p>项目描述需要简单说明一下项目的业务，这里注意要体现项目的亮点，不要一两句话概括项目的业务，更不要直接甩一个项目名称，而不说明项目基本业务，除非你做的项目是业界非常知名的大项目，否则这样做无疑是自己给自己挖坑。</p> <p>反例：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ESOP 项目负责协助公司管理发放给员工的股权激励。
</code></pre></div></div> <p>这一句话好像啥都说了，又好像啥都没说。</p> <p>把项目吸引眼球的亮点写出来，比如交易、分布式事务、微服务……高大上的名词网上靠。</p> <p>涉及的技术，这一块最好不要只列举一些名词，简单介绍一下引入的目的，比如：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>使用 RabbitMQ 做微服务的异步调用，削峰平谷；
使用 Dubbo 做 RPC 调用；
使用 Kafka 做日志处理分析；
......
</code></pre></div></div> <p>本人负责的内容，这里最好能详细列出几条高大上的，能引导面试官提问。</p> <p>这是我修改后的<a href="https://wzm001.github.io/assets/pdf/cv.pdf">简历</a>。</p>]]></content><author><name></name></author><category term="面试"/><category term="面试"/><category term="简历"/><summary type="html"><![CDATA[简历优化]]></summary></entry><entry><title type="html">缓存引入的问题</title><link href="https://wzm001.github.io//blog/2023/cache-problems/" rel="alternate" type="text/html" title="缓存引入的问题"/><published>2023-05-05T13:50:16+00:00</published><updated>2023-05-05T13:50:16+00:00</updated><id>https://wzm001.github.io//blog/2023/cache-problems</id><content type="html" xml:base="https://wzm001.github.io//blog/2023/cache-problems/"><![CDATA[<p>缓存是系统不可缺少的一部分。大多数系统都建立了多级缓存的架构，从客户端浏览器缓存，到 CDN，到 Nginx 缓存，再到后端的分布式缓存，再到节点的本地缓存…… 各级缓存相互协调，给用户带来流畅的体验，也保护后端系统免受大流量的冲击。</p> <p>然而设计不当的缓存系统，也会引入其他问题。本文针对后端常用的分布式缓存系统，说明一下常见的几种问题场景。</p> <h1 id="缓存穿透-cache-penetration">缓存穿透 Cache penetration</h1> <p>缓存系统的工作流程都类似，请求到达后台后，先从缓存中查找，命中缓存后直接返回。如果缓存没有命中，就从下一层数据系统（一般是数据库）查找，并将对应的值放到缓存中返回。</p> <p>而缓存穿透的场景是，请求对应的数据在缓存中不存在，数据库中也查找不到，因此无法更新缓存，导致请求直接打到了数据库上，好像缓存不存在一样，因此叫“穿透”。这种场景可能是代码缺陷导致，也可能是恶意用户故意构建错误的请求攻击后台。如果大流量的请求穿透缓存打到数据库，就可能导致服务不可用。</p> <h2 id="解决方案">解决方案</h2> <ol> <li>业务层面过滤非法请求。比如查询年龄为 -1 的用户。这种方式最为常用，通常在 controller 层加上 <code class="language-plaintext highlighter-rouge">Hibernate Validation</code> ，配合 Spring 框架的注解实现对参数的校验。</li> <li>如果是业务层面合法的请求，但后台 <em>暂时</em> 没有数据，可以考虑将 <code class="language-plaintext highlighter-rouge">null</code> 缓存下来。但这时候需要注意，这个缓存是临时性的，因为后续可能该数据就不为空了。所以缓存的时候可以给个稍微短一些的过期时间，比如 5 分钟。并且当数据库写入或更新数据时，需要同时刷新缓存以避免数据不一致。</li> <li>使用布隆过滤器判断对应的 key 是否存在。布隆过滤器是一种特殊的数据结构，它用来判断 key 是否存在。原理很简单，布隆过滤器底层是一个位图（bitmap），可以理解为一个数组，数组元素就是二进制位（1 bit）。当 key 被加入到过滤器中，首先会经过一系列 hash 运算，每次 hash 运算都会计算出一个位图的坐标，标记该位置位 1。经过多次 hash 后，位图的某些位置就更新为 1 了。当需要判断 key 是否存在时，用同样的规则计算 hash，并查看对应坐标的值是否为 1，如果不为 1，那说明这个 key 肯定没有出现过。但如果对应的坐标值都为 1，却不能确定该值一定出现过，这是因为存在 hash 冲突，不同的 key 可能对应了同一个 hash 值，并且位图的长度也是有限的。因此如果要提高布隆过滤器的精度，需要增加位图的长度，并增加 hash 运算的次数，把冲突分散开。</li> <li>上面的措施都是事前预防。也要注意监控线上的分布式缓存状态，如果在一段时间内发生大量未命中的请求，需要及时关注是否出现缓存穿透的问题并尽快处理。</li> </ol> <h1 id="缓存雪崩-cache-avalanche">缓存雪崩 Cache avalanche</h1> <p>缓存雪崩的场景是分布式缓存大面积失效，有可能是大量的缓存同时过期，或者缓存系统不可用，导致原本缓存系统承担的流量都涌入后台数据库，因为后台没有考虑承载如此巨大的流量，导致直接崩溃，进而导致整个系统不可用，引发连锁反应。</p> <h2 id="解决方案-1">解决方案</h2> <ol> <li>如果是热点数据，可以考虑去掉过期时间，让该热点缓存一直有效，使用后台线程更新缓存。但这种方案需要忍受一段时间的数据不一致。</li> <li>如果缓存对过期时间敏感，则可以尽量将过期时间分散开，比如一批缓存都是一分钟过期，可以给某些 key 设置 59 秒，某些 key 设置 61 秒，避免大量缓存同时过期引起雪崩。</li> <li>使用双缓存（Double caching）。添加两份相同数据的缓存，一个设置过期时间，另一个不设置过期时间。如果一个缓存过期，就从另一个缓存获取数据。更新缓存的时候同时更新两个缓存。</li> <li>给数据库添加限流措施，如锁或者队列，防止大量请求同时到达数据库。</li> <li>给缓存添加高可用机制，如主从切换，分布式等措施，减少缓存系统发生故障的概率。</li> </ol> <h1 id="缓存击穿-cache-breakdown">缓存击穿 Cache breakdown</h1> <p>缓存击穿容易和缓存雪崩混淆，这个翻译我觉得有点问题，叫缓存失效可能更好理解。它是指某个热点数据过期，导致大量请求打到数据库，给数据库造成很大的压力。</p> <p>缓存击穿是缓存雪崩的一个子集。两者都是缓存失效导致的，缓存击穿的问题规模较小，是某个热点数据突然过期导致的，而缓存雪崩通常伴随的是大量的缓存失效甚至缓存系统都不可用。缓存击穿有可能是系统能自己恢复，如果数据库能扛住击穿后的瞬时流量，并且业务系统有缓存更新的方案，如果没有的话，缓存击穿就像是千里之堤溃于蚁穴，会演变成缓存雪崩。</p> <h2 id="解决方案-2">解决方案</h2> <ol> <li>如果是热点数据，意味着该数据一直承载着大量的访问请求，这种情况不要设置过期时间，而是使用异步线程更新或重写缓存。这会带来一段时间的数据不一致。</li> <li>使用互斥的方式更新缓存。这本质上是给数据库限流。当缓存失效时，一个请求开始查询数据库更新缓存，其他请求阻塞等待，直到缓存更新完成之后，其他请求再从缓存中获取数据。这会带来一段时间的系统吞吐量降低。</li> <li>给数据库添加限流措施，防止大量请求到达数据库。</li> </ol> <h1 id="数据不一致">数据不一致</h1> <p>数据不一致是所有缓存系统都可能面临的问题。当数据发生变化时，数据库和缓存这两个数据源都需要更新，但这两个更新的操作一般不是原子性的，在高并发下就会出现不一致的情况。下面具体分析一下出现问题的几个场景。</p> <p>TODO</p>]]></content><author><name></name></author><category term="Cache"/><category term="Redis"/><category term="Cache"/><category term="Redis"/><summary type="html"><![CDATA[缓存穿透、缓存击穿、缓存雪崩、数据不一致]]></summary></entry><entry><title type="html">高并发架构：分布式系统</title><link href="https://wzm001.github.io//blog/2023/distributed-system/" rel="alternate" type="text/html" title="高并发架构：分布式系统"/><published>2023-04-22T07:45:16+00:00</published><updated>2023-04-22T07:45:16+00:00</updated><id>https://wzm001.github.io//blog/2023/distributed-system</id><content type="html" xml:base="https://wzm001.github.io//blog/2023/distributed-system/"><![CDATA[<p>分布式系统是一些独立的计算机合集，但对于这个系统的用户来说，系统表现得就像是一台计算机一样。</p>]]></content><author><name></name></author><category term="架构"/><category term="分布式"/><category term="架构"/><category term="分布式"/><summary type="html"><![CDATA[分布式系统的概念]]></summary></entry><entry><title type="html">高并发架构：熔断和降级</title><link href="https://wzm001.github.io//blog/2023/downgrade-circuitbreaker/" rel="alternate" type="text/html" title="高并发架构：熔断和降级"/><published>2023-04-21T07:45:16+00:00</published><updated>2023-04-21T07:45:16+00:00</updated><id>https://wzm001.github.io//blog/2023/downgrade-circuitbreaker</id><content type="html" xml:base="https://wzm001.github.io//blog/2023/downgrade-circuitbreaker/"><![CDATA[<p>熔断和降级，还有上一章提到的限流，都是服务容错的设计。分布式架构中如果没有良好的容错设计，一旦链路上某个服务发生故障，很容易引发雪崩效应。</p> <p>例如业务链路上某服务响应缓慢，那么依赖它的上游服务也会延迟响应，如此一级一级向上传递，导致整个业务都出现响应缓慢的问题，严重时还可能出现拒绝服务的情况。</p> <p>熔断和降级，就是为了避免上述问题的出现。</p> <h1 id="降级">降级</h1> <blockquote> <p>由于爆炸性的流量冲击，对一些服务进行有策略的放弃，以此缓解系统压力，保证目前主要业务的正常运行。它主要针对非正常情况下的应急服务措施：当此时一些业务服务无法执行时，给出一个统一的返回结果。</p> </blockquote> <h2 id="服务降级的特征">服务降级的特征</h2> <ul> <li>原因：系统整体负荷超出其承载能力；</li> <li>目的：保证重要或基本服务的运行，非核心服务延迟使用或暂停使用；（弃车保帅）</li> <li>粒度：降低服务粒度，将降级粒度控制在合理范围内；</li> <li>可控性：可分为手动降级和自动降级。在服务侧有开关配置，允许人工介入；</li> <li>次序：服务配置优先级。先把优先级最低的服务降级；</li> </ul> <h2 id="降级方式">降级方式</h2> <ul> <li>延迟服务：比如论坛的发表评论服务是重要服务，需要有限保证，但评论完增加积分是次要业务，可以先把请求放到缓存中，等服务平稳之后再执行；</li> <li>在粒度范围内关闭服务：比如关闭相关的商品推荐，返回静态资源，或者直接关闭推荐区；</li> <li>页面异步请求降级：比如订单页面上展示的物流信息如果接口返回缓慢，可以先不调用；</li> <li>页面跳转（页面降级）：前端直接不去家在某个页面，而是直接跳转到固定地址。如秒杀活动，可以直接跳转到“人太多请稍后重试”的页面上；</li> <li>写降级：比如秒杀抢购，我们可以只进行 Cache 更新，然后异步扣件库存到 DB，保证最终一致性即可，此时是将 DB 降级为 Cache；</li> <li>读降级：比如多级缓存模式，如果后端服务有问题，可以降级为只读缓存，这种方式适用于对读一致性不高的场景；</li> </ul> <h2 id="降级分类">降级分类</h2> <p>按照是否自动化可分为自动降级和手动降级。自动降级一般是系统检测到下游服务有异常情况而采取的措施，手动降级则是综合考虑系统整体负载而做出的取舍策略。</p> <h3 id="自动降级">自动降级</h3> <p>自动降级是系统自发的行为，因此自动降级也需要伴随一定的自动恢复策略，否则运维人员就炸锅了。</p> <ul> <li>超时降级：配置好下游服务的超时时间和重试次数，达到阈值后进行降级，降级后使用异步机制探测服务恢复情况；</li> <li>失败次数降级：下游不稳定的 api，当失败调用次数达到一定阈值后进行的降级；</li> <li>故障降级：下游服务挂了（网络故障、RPC 服务异常等），直接进行降级。降级后可以返回默认值、兜底数据或者从缓存中读取；</li> <li>限流降级：下游达到限流阈值后进行降级，降级后的处理方案可以是：排队页面、错误页面等；</li> </ul> <h1 id="熔断">熔断</h1> <p>熔断是指请求下游服务失败或响应时间过长的数量达到阈值，上游服务主动断开，不再继续调用下游服务。熔断是降级的一种，对应上面提到的自动降级。</p> <h2 id="断路器curcuit-breaker">断路器（Curcuit Breaker）</h2> <p>断路器模式是实现熔断的方式。断路器就像电气系统里的保险丝，把错误隔离，防止出现服务雪崩。</p> <p>基本断路器的结构如下图：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/curcuit-breaker-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/curcuit-breaker-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/curcuit-breaker-1400.webp"/> <img src="/assets/img/curcuit-breaker.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>它有两种状态（close 和 open）和一个基本 trip 动作：</p> <ul> <li>close 状态下，断路器不工作，client 向 supplier 发起的请求直接无阻碍通过断路器，supplier 返回的结果也直接通过断路器到达 client，相当于断路器不存在；</li> <li>open 状态下，client 向 supplier 发起的请求会被断路器拦截，直接返回 client，此时断路器无法通过；</li> <li>trip 动作：是指断路器在 close 状态下，如果 supplier 持续报错或超时，达到规定的阈值后，断路器由 close 转为 open 状态的动作。</li> </ul> <p>基本模式的断路器，自身没有自动恢复的操作，需要外界介入。扩展模式的断路器结构如下图：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/curcuit-breaker2-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/curcuit-breaker2-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/curcuit-breaker2-1400.webp"/> <img src="/assets/img/curcuit-breaker2.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>相比基本断路器，扩展断路器增加了一个半开状态：</p> <ul> <li>HALF-OPEN：断路器自动恢复的状态。当断路器 OPEN 状态一段时间后，将“自动”（一般是由下一次请求而不是计时器触发的，所以这里自动带引号）切换到 HALF OPEN 状态。该状态下，会放行一次远程调用，然后根据这次调用的结果成功与否，转换为 CLOSED 或者 OPEN 状态，以实现断路器的弹性恢复。</li> </ul> <h1 id="方案">方案</h1> <ul> <li>Spring Cloud Netflix Hystrix 就是隔离措施的一种实现，可以设置在某种超时或者失败情形下断开依赖调用或者返回指定逻辑，从而提高分布式系统的稳定性。</li> <li>Sentinel 是阿里中间件团队开源的，面向分布式服务架构的轻量级高可用流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户保护服务的稳定性。</li> </ul> <h1 id="参考">参考</h1> <ul> <li><a href="https://pdai.tech/md/arch/arch-y-reduce.html#%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7">架构之高并发：降级和熔断</a></li> <li><a href="https://icyfenix.cn/distribution/traffic-management/failure.html">服务容错</a></li> </ul>]]></content><author><name></name></author><category term="架构"/><category term="高并发"/><category term="架构"/><category term="熔断"/><category term="降级"/><summary type="html"><![CDATA[熔断和降级的概念以及区别]]></summary></entry><entry><title type="html">高并发架构：限流</title><link href="https://wzm001.github.io//blog/2023/rate-limiter/" rel="alternate" type="text/html" title="高并发架构：限流"/><published>2023-04-19T13:45:16+00:00</published><updated>2023-04-19T13:45:16+00:00</updated><id>https://wzm001.github.io//blog/2023/rate-limiter</id><content type="html" xml:base="https://wzm001.github.io//blog/2023/rate-limiter/"><![CDATA[<p>首先看一个计算系统最大吞吐量的例子：</p> <blockquote> <p>已知条件：</p> <ol> <li>系统中每个业务操作需要调用 10 个服务来协调完成（顺序调用）</li> <li>该业务操作的总超时时间为 10 s</li> <li>每个服务实例的处理时间平均为 0.5 s</li> <li>集群中每个服务均部署了 20 个实例副本</li> </ol> <p>求解以下问题：</p> <ul> <li> <p>单个用户访问，完成一次业务操作，需要耗费系统多少 <em>处理器时间</em> ?</p> <p>答：0.5 × 10 = 5 s <strong>CPU Time</strong></p> </li> <li> <p>集群中每个服务每秒最大能处理多少请求？</p> <p>答：(1 ÷ 0.5) × 20 = 40 <strong>QPS</strong></p> </li> <li> <p>假设不考虑顺序且请求分发是均衡的，在保证不超时的前提下，系统（整个集群）每秒最多处理多少笔业务？</p> <p>答：40 × 10 ÷ 5 = 80 <strong>TPS</strong></p> </li> <li> <p>如果集群在一段时间内持续收到 100 TPS 的请求，会出现什么情况？</p> </li> </ul> </blockquote> <h1 id="什么是限流">什么是限流</h1> <p><em>限流</em> 是系统对服务的保护措施，一般是上游服务配置好限流规则，防止突发流量把下游服务打爆。假设服务每秒能支撑最多 50 个请求，如果遇到流量高峰，一秒内打进来 80 个请求，就会导致服务崩溃。这里的崩溃指的是服务连一个请求都无法处理了，因为服务器的资源已经用完，无法支撑系统运行了。就像早期的 12306 购票网站，如果大量的人都抢票，就会把服务打崩，导致大家都买不上票。</p> <p>限流要达到的目的就是让服务在处于超过自己处理能力的高并发情况下，还能继续处理自己能力内的那部分请求，拒绝多出来的请求。就像上面的例子，服务器在一秒 80 个请求的前提下，还能正常处理 50 个请求，只把剩余的 30 个请求拒绝掉（或者放到队列中等待后续处理）。</p> <h1 id="依据什么限流-限流指标">依据什么限流-限流指标</h1> <p>限流需要有明确的流量指标用来进行判断。对于服务而言，一般有三种流量指标来反映流量压力的大小。</p> <h2 id="每秒事务数transactions-per-second-tps">每秒事务数（Transactions per Second, TPS）</h2> <p><code class="language-plaintext highlighter-rouge">TPS</code> 是衡量信息系统吞吐量的最终标准。“事务”可以理解为一个逻辑上具备原子性的操作，只有成功和失败两种状态。事务在不同的服务上有不同的定义，比如下单操作。</p> <h2 id="每秒请求数hits-per-second-hps">每秒请求数（Hits per Second, HPS）</h2> <p><code class="language-plaintext highlighter-rouge">HPS</code> 指的是每秒从客户端向服务端发起的请求数。如果只要一个请求就能完成一笔业务，那么 <code class="language-plaintext highlighter-rouge">HPS</code> 和 <code class="language-plaintext highlighter-rouge">TPS</code> 是等价的。但在一些场景中，一笔业务可能需要发送多次请求才能完成，比如支付业务，可能需要分为生成二维码、扫码支付、校验等多个请求。</p> <h2 id="每秒查询数queries-per-second-qps">每秒查询数（Queries per Second, QPS）</h2> <p><code class="language-plaintext highlighter-rouge">QPS</code> 指的是服务器能够响应的查询次数。如果只有一台服务器来应答请求，那么 <code class="language-plaintext highlighter-rouge">QPS</code> 和 <code class="language-plaintext highlighter-rouge">HPS</code> 是等价的。但在分布式系统中，一个请求的响应往往要由后台多个服务节点共同协作完成。因此 <code class="language-plaintext highlighter-rouge">1 HPS</code> 一般可以对应多个 <code class="language-plaintext highlighter-rouge">QPS</code>。</p> <p>=======================</p> <p>上面提到的这三种指标，都是基于计数来做统计的。在整体目标上我们最希望使用 <code class="language-plaintext highlighter-rouge">TPS</code> 指标来限流，因为这个指标最接近业务。但是系统业务五花八门，不同的业务操作对系统的压力也往往差异巨大，所以不同服务的 <code class="language-plaintext highlighter-rouge">TPS</code> 没有什么可比性。更关键的是，流量控制是针对用户实际操作场景来限流的，而用户的操作时间具有不确定性，可能用户扫码后等待了几分钟后才付款，这时候统计的 <code class="language-plaintext highlighter-rouge">TPS</code> 是反映不了系统压力的，因此直接针对 <code class="language-plaintext highlighter-rouge">TPS</code> 限流实际上很难操作。</p> <p>目前，大多数系统都倾向于使用 <code class="language-plaintext highlighter-rouge">HPS</code> 作为限流指标。<code class="language-plaintext highlighter-rouge">HPS</code> 容易观察统计，也能在一定程度上反映系统当前和接下来一段时间的压力。</p> <p>但限流指标没有明确的法则可以遵循，需要根据系统的实际业务来定。比如下载、视频、直播等 I/O 密集型服务，会选择请求和响应的报文大小作为限流指标，比如只允许单位时间内通过 100M 流量。又比如网络游戏等基于长连接的服务，可能会把登陆用户作为限流指标，比如热门网游在超过一定用户数就会让你在登陆前排队。</p> <h2 id="如何测量指标">如何测量指标</h2> <p>这三种指标都是基于计数做统计的。常用的统计方法有两种。</p> <h3 id="计数器">计数器</h3> <p>这是最简单的统计方法。计数器统计的是当前服务正在进行中的任务，例如服务接收到一个请求，就在内部计数器上加 1，服务返回一个请求（正常返回或超时返回），就在内部计数器上减 1。当服务计数器达到最大数量后，新的请求就会被限制。</p> <p>后台定时任务每秒获取一次计数器的值，得到的就是统计指标了。例如第一秒计数器值为10，指标就是 10 TPS（或 QPS 等，和统计场景有关）。下一秒计数器值为 9，指标就是 9 TPS。</p> <p>但这种统计方式有缺陷，得到的指标并不能准确体现当时系统的流量压力。比如：</p> <ol> <li>即使统计结果显示每秒的 TPS 都不超过 80，也不能说明系统没有遇到过大于 80 TPS 的压力。假设两个统计周期内系统都收到了 60 TPS 的请求，但两个 60 TPS 的请求分别发生在前一秒里的后 0.5 秒和下一秒里的前 0.5 秒。这样统计出来的结果都是 60 TPS，但系统确实在 1s 内实实在在发生了超过阈值的 120 TPS 请求。</li> <li>假设某服务处理一个请求的平均时长为 2s，可以支撑 10 TPS 的请求。计数器在某一秒内统计的 TPS 达到了 20，看起来好像超过了阈值，但这个时候系统是在正常运行中的。因为第一秒接收了 10 个请求，第二秒又接收了 10 个请求，此时第一秒的请求还在正常处理，虽然第二秒的统计指标是 20 TPS。如果系统基于 10 TPS 来做限流，反而会误杀一部分正常请求，造成不必要的请求失败。</li> </ol> <p>计数器缺陷的根源是只针对离散的时间点做统计，没有体现出一段时间的流量情况。</p> <h3 id="滑动时间窗">滑动时间窗</h3> <p>滑动时间窗是一种更准确的统计方法，它统计一段时间内的流量情况。它其实还是依赖了计数器统计，区别是统计一段时间内的计数器值。比如服务端需要统计 10s 内的流量情况，维护了一个长度为 10 的队列。定时任务每秒访问一次计数器的值，并将其压入队列。当队列满了以后，再次入队就会把队首的记录淘汰。这个队列就是一个固定长度的时间窗，窗内可以观察最近 10s 内的流量情况，以此做为限流或熔断的依据。</p> <p><a href="https://github.com/Netflix/Hystrix">Hystrix</a> 就使用了这种统计方式，下面是 <a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works">Hystrix 官方文档</a> 中的示意图：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/hystrix-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/hystrix-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/hystrix-1400.webp"/> <img src="/assets/img/hystrix.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Hystrix 统计的指标更详细，可以看到它同时记录了成功、失败、超时、拒绝四种类型的数据，通过这些指标来确定断路器的状态。</p> <h1 id="具体如何限流-限流模式">具体如何限流-限流模式</h1> <p>现在我们定义了流量的指标，也知道了服务器当前的指标值。接下来具体需要如何去限流呢？</p> <h2 id="流量计数器模式">流量计数器模式</h2> <p>计数器我们在指标测量里提到过，这是最基础的限流方式。计数器限制的是访问资源的总并发数。这种限流方式通常用在资源数量固定的场景，例如数据库连接池、线程池、服务并发访问数等。流量计数器的实现方式简单，可以应对一定程度的突发流量。</p> <p>Java 中可以通过 <code class="language-plaintext highlighter-rouge">AtomicInteger</code> 、信号量 <code class="language-plaintext highlighter-rouge">Semaphore</code> 或者固定数量的线程池来实现。</p> <p>计数器的弊端：瞬时流量高也会拒绝请求。</p> <h2 id="令牌桶模式token-bucket">令牌桶模式（Token Bucket）</h2> <p>令牌桶算法是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常用的算法。先有一个木桶，系统按照固定速率，往桶里加入令牌，如果桶已经满了就停止添加。请求进来时，先去桶里拿走一个令牌，取到令牌才可以继续进行请求处理，没有令牌系统就拒绝服务。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/token-bucket-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/token-bucket-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/token-bucket-1400.webp"/> <img src="/assets/img/token-bucket.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <blockquote> <p>令牌桶和信号量的区别？</p> <p>首先，信号量的信号和令牌桶的令牌都是固定数目的可用资源，两者在资源控制上的作用是相同的。</p> <p>其次，信号量的资源是被动释放的，令牌桶的资源是以固定速率生成的。被信号量控制的资源数据一定不会大于信号量自身定义的容量。但令牌桶发放的且正在被使用的令牌，有可能大于桶的容量。</p> <p>举个例子，令牌桶就像是饭店门口的服务员，负责发号。信号量就是饭店里的位置，是固定资源。</p> <p>令牌桶控制的是请求速率，信号量控制的是资源访问，两者关注的角度不同。</p> </blockquote> <p>未被使用的令牌会存放在桶里，如果有突然流量进来，只要 Token 足够，就可以一次性放行。因此令牌桶算法支持突发流量。</p> <p>Guava <code class="language-plaintext highlighter-rouge">RateLimiter</code> 提供了令牌桶算法实现：平滑突发限流(SmoothBursty)和平滑预热限流(SmoothWarmingUp)实现。</p> <h2 id="漏桶模式leaky-bucket">漏桶模式（Leaky Bucket）</h2> <p>水（请求）先进入漏桶中，漏桶以固定速率出水，当桶里的水满（请求达到阈值）后，接下来的请求就被丢弃。可以看到漏桶能强制限定数据的传输速率。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/leaky-bucket-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/leaky-bucket-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/leaky-bucket-1400.webp"/> <img src="/assets/img/leaky-bucket.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>漏桶和令牌桶的区别：</p> <ol> <li>令牌桶限制的是 <em>平均流入速率</em> ，并允许一定程度的突发流量；</li> <li>漏桶限制的是 <em>常量流出速率</em> ，无论进入的流量多大，流出的流量是固定不变的；</li> </ol> <blockquote> <p>漏桶和消息队列的区别？</p> <p>可以看到，漏桶起到的作用和消息队列的削峰类似。两者的主要区别是获取数据的方式。 漏桶是把数据推送到下游，消息队列则是下游主动拉取数据。因此漏桶可以控制消息流入的速率，而消息队列不能控制，流入速率只能取决于下游的消费速率。</p> </blockquote> <h1 id="超额的流量如何处理">超额的流量如何处理？</h1> <p>根据不同的业务，有两种处理方式：</p> <ol> <li>直接返回失败（如 429: Too Many Requests），或者迫使上游进入降级逻辑，称为 <em>否决式限流</em> ；</li> <li>进入队列等待或阻塞一段时间后继续处理，称为 <em>阻塞式限流</em> ；</li> </ol> <p>在不引入其他组件的前提下讨论，用 <code class="language-plaintext highlighter-rouge">AtomicInteger</code> 实现的计数器就是否决式限流，用信号量实现的计数器就可以是阻塞式限流，因为请求可以进入阻塞队列等待。</p> <h1 id="参考">参考</h1> <ul> <li><a href="https://pdai.tech/md/arch/arch-y-ratelimit.html">架构之高并发：限流</a></li> <li><a href="https://icyfenix.cn/distribution/traffic-management/traffic-control.html">流量控制</a></li> </ul>]]></content><author><name></name></author><category term="架构"/><category term="高并发"/><category term="架构"/><category term="限流"/><summary type="html"><![CDATA[常见的限流算法以及使用场景]]></summary></entry><entry><title type="html">Java NIO 概念梳理</title><link href="https://wzm001.github.io//blog/2023/java-nio/" rel="alternate" type="text/html" title="Java NIO 概念梳理"/><published>2023-04-15T13:45:16+00:00</published><updated>2023-04-15T13:45:16+00:00</updated><id>https://wzm001.github.io//blog/2023/java-nio</id><content type="html" xml:base="https://wzm001.github.io//blog/2023/java-nio/"><![CDATA[<p>看了很多零零散散的 NIO 文章，但没有形成系统的认识。今天尝试整理一下 NIO 的相关概念。</p> <h1 id="什么是-nio">什么是 NIO</h1> <p>Java 提供的传统 IO 模型称为 BIO (阻塞 IO，Blocking IO)，而 NIO 称为“非阻塞 IO” （Non-blocking IO）。传统 IO 是面向输入/输出流（InputStream / OutputStream）的，NIO 是面向通道（Channel）的。</p> <p>在进一步介绍概念之前，我们先理解一下什么是 <em>阻塞</em> 。</p> <blockquote> <p>阻塞从概念上理解，指的是当前工作卡在某个点无法进行下去。从编程模型上讲，阻塞的对象就是线程。线程从运行态转为阻塞态，不再占用 CPU 资源，就代表该线程被阻塞。</p> </blockquote> <p>假如某线程要读取一个文件：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"/Users/tiger/test.txt"</span><span class="o">);</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">buf</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
<span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buf</span><span class="o">);</span> <span class="c1">// 此方法会阻塞线程，在数据读取完成之前，下面的代码无法执行</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">buf</span><span class="o">));</span>
</code></pre></div></div> <p>我们看到，在传统 BIO 模型下，<code class="language-plaintext highlighter-rouge">InputStream</code> 的 <code class="language-plaintext highlighter-rouge">read()</code> 方法会阻塞线程，此时 JVM 会调用操作系统读取文件，程序从用户态转为内核态，当操作系统将文件读取完成并且把数据从内核缓冲区拷贝到 JVM 的内存中后，该线程才会被唤起继续执行。大概的流程如下图：</p> <div class="jekyll-diagrams diagrams mermaid"> <svg id="mermaid-1686152183322" width="100%" xmlns="http://www.w3.org/2000/svg" height="100%" style="max-width:650px;" viewBox="-50 -10 650 347"><style>#mermaid-1686152183322 .label{font-family:trebuchet ms,verdana,arial;color:#333}#mermaid-1686152183322 .node circle,#mermaid-1686152183322 .node ellipse,#mermaid-1686152183322 .node polygon,#mermaid-1686152183322 .node rect{fill:#ececff;stroke:#9370db;stroke-width:1px}#mermaid-1686152183322 .node.clickable{cursor:pointer}#mermaid-1686152183322 .arrowheadPath{fill:#333}#mermaid-1686152183322 .edgePath .path{stroke:#333;stroke-width:1.5px}#mermaid-1686152183322 .edgeLabel{background-color:#e8e8e8}#mermaid-1686152183322 .cluster rect{fill:#ffffde!important;stroke:#aa3!important;stroke-width:1px!important}#mermaid-1686152183322 .cluster text{fill:#333}#mermaid-1686152183322 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:trebuchet ms,verdana,arial;font-size:12px;background:#ffffde;border:1px solid #aa3;border-radius:2px;pointer-events:none;z-index:100}#mermaid-1686152183322 .actor{stroke:#ccf;fill:#ececff}#mermaid-1686152183322 text.actor{fill:#000;stroke:none}#mermaid-1686152183322 .actor-line{stroke:grey}#mermaid-1686152183322 .messageLine0{marker-end:"url(#arrowhead)"}#mermaid-1686152183322 .messageLine0,#mermaid-1686152183322 .messageLine1{stroke-width:1.5;stroke-dasharray:"2 2";stroke:#333}#mermaid-1686152183322 #arrowhead{fill:#333}#mermaid-1686152183322 #crosshead path{fill:#333!important;stroke:#333!important}#mermaid-1686152183322 .messageText{fill:#333;stroke:none}#mermaid-1686152183322 .labelBox{stroke:#ccf;fill:#ececff}#mermaid-1686152183322 .labelText,#mermaid-1686152183322 .loopText{fill:#000;stroke:none}#mermaid-1686152183322 .loopLine{stroke-width:2;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#ccf}#mermaid-1686152183322 .note{stroke:#aa3;fill:#fff5ad}#mermaid-1686152183322 .noteText{fill:#000;stroke:none;font-family:trebuchet ms,verdana,arial;font-size:14px}#mermaid-1686152183322 .section{stroke:none;opacity:.2}#mermaid-1686152183322 .section0{fill:rgba(102,102,255,.49)}#mermaid-1686152183322 .section2{fill:#fff400}#mermaid-1686152183322 .section1,#mermaid-1686152183322 .section3{fill:#fff;opacity:.2}#mermaid-1686152183322 .sectionTitle0,#mermaid-1686152183322 .sectionTitle1,#mermaid-1686152183322 .sectionTitle2,#mermaid-1686152183322 .sectionTitle3{fill:#333}#mermaid-1686152183322 .sectionTitle{text-anchor:start;font-size:11px;text-height:14px}#mermaid-1686152183322 .grid .tick{stroke:#d3d3d3;opacity:.3;shape-rendering:crispEdges}#mermaid-1686152183322 .grid path{stroke-width:0}#mermaid-1686152183322 .today{fill:none;stroke:red;stroke-width:2px}#mermaid-1686152183322 .task{stroke-width:2}#mermaid-1686152183322 .taskText{text-anchor:middle;font-size:11px}#mermaid-1686152183322 .taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px}#mermaid-1686152183322 .taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}#mermaid-1686152183322 .taskText0,#mermaid-1686152183322 .taskText1,#mermaid-1686152183322 .taskText2,#mermaid-1686152183322 .taskText3{fill:#fff}#mermaid-1686152183322 .task0,#mermaid-1686152183322 .task1,#mermaid-1686152183322 .task2,#mermaid-1686152183322 .task3{fill:#8a90dd;stroke:#534fbc}#mermaid-1686152183322 .taskTextOutside0,#mermaid-1686152183322 .taskTextOutside1,#mermaid-1686152183322 .taskTextOutside2,#mermaid-1686152183322 .taskTextOutside3{fill:#000}#mermaid-1686152183322 .active0,#mermaid-1686152183322 .active1,#mermaid-1686152183322 .active2,#mermaid-1686152183322 .active3{fill:#bfc7ff;stroke:#534fbc}#mermaid-1686152183322 .activeText0,#mermaid-1686152183322 .activeText1,#mermaid-1686152183322 .activeText2,#mermaid-1686152183322 .activeText3{fill:#000!important}#mermaid-1686152183322 .done0,#mermaid-1686152183322 .done1,#mermaid-1686152183322 .done2,#mermaid-1686152183322 .done3{stroke:grey;fill:#d3d3d3;stroke-width:2}#mermaid-1686152183322 .doneText0,#mermaid-1686152183322 .doneText1,#mermaid-1686152183322 .doneText2,#mermaid-1686152183322 .doneText3{fill:#000!important}#mermaid-1686152183322 .crit0,#mermaid-1686152183322 .crit1,#mermaid-1686152183322 .crit2,#mermaid-1686152183322 .crit3{stroke:#f88;fill:red;stroke-width:2}#mermaid-1686152183322 .activeCrit0,#mermaid-1686152183322 .activeCrit1,#mermaid-1686152183322 .activeCrit2,#mermaid-1686152183322 .activeCrit3{stroke:#f88;fill:#bfc7ff;stroke-width:2}#mermaid-1686152183322 .doneCrit0,#mermaid-1686152183322 .doneCrit1,#mermaid-1686152183322 .doneCrit2,#mermaid-1686152183322 .doneCrit3{stroke:#f88;fill:#d3d3d3;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}#mermaid-1686152183322 .activeCritText0,#mermaid-1686152183322 .activeCritText1,#mermaid-1686152183322 .activeCritText2,#mermaid-1686152183322 .activeCritText3,#mermaid-1686152183322 .doneCritText0,#mermaid-1686152183322 .doneCritText1,#mermaid-1686152183322 .doneCritText2,#mermaid-1686152183322 .doneCritText3{fill:#000!important}#mermaid-1686152183322 .titleText{text-anchor:middle;font-size:18px;fill:#000}
#mermaid-1686152183322 g.classGroup text{fill:#9370db;stroke:none;font-family:trebuchet ms,verdana,arial;font-size:10px}#mermaid-1686152183322 g.classGroup rect{fill:#ececff;stroke:#9370db}#mermaid-1686152183322 g.classGroup line{stroke:#9370db;stroke-width:1}#mermaid-1686152183322 .classLabel .box{stroke:none;stroke-width:0;fill:#ececff;opacity:.5}#mermaid-1686152183322 .classLabel .label{fill:#9370db;font-size:10px}#mermaid-1686152183322 .relation{stroke:#9370db;stroke-width:1;fill:none}#mermaid-1686152183322 #compositionEnd,#mermaid-1686152183322 #compositionStart{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-1686152183322 #aggregationEnd,#mermaid-1686152183322 #aggregationStart{fill:#ececff;stroke:#9370db;stroke-width:1}#mermaid-1686152183322 #dependencyEnd,#mermaid-1686152183322 #dependencyStart,#mermaid-1686152183322 #extensionEnd,#mermaid-1686152183322 #extensionStart{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-1686152183322 .branch-label,#mermaid-1686152183322 .commit-id,#mermaid-1686152183322 .commit-msg{fill:#d3d3d3;color:#d3d3d3}</style><style>#mermaid-1686152183322{color:#000;font:normal normal 400 normal 16px / normal "Times New Roman"}</style><g></g><g><line id="actor0" x1="75" y1="5" x2="75" y2="336" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="0" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="75" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle;"><tspan x="75" dy="0">JVM</tspan></text></g><g><line id="actor1" x1="275" y1="5" x2="275" y2="336" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="200" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="275" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle;"><tspan x="275" dy="0">OS_Core</tspan></text></g><g><line id="actor2" x1="475" y1="5" x2="475" y2="336" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="400" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="475" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle;"><tspan x="475" dy="0">Disk</tspan></text></g><defs><marker id="arrowhead" refX="5" refY="2" markerWidth="6" markerHeight="4" orient="auto"><path d="M 0,0 V 4 L6,2 Z"></path></marker></defs><defs><marker id="crosshead" markerWidth="15" markerHeight="8" orient="auto" refX="16" refY="4"><path fill="black" stroke="#000000" stroke-width="1px" d="M 9,2 V 6 L16,4 Z" style="stroke-dasharray: 0, 0;"></path><path fill="none" stroke="#000000" stroke-width="1px" d="M 0,1 L 6,7 M 6,1 L 0,7" style="stroke-dasharray: 0, 0;"></path></marker></defs><g><text x="175" y="93" class="messageText" style="text-anchor: middle;">调用操作系统读取文件</text><line x1="75" y1="100" x2="275" y2="100" class="messageLine0" stroke-width="2" stroke="black" marker-end="url(#arrowhead)" style="fill: none;"></line></g><g><rect x="70" y="102" fill="#f4f4f4" stroke="#666" width="10" height="149" rx="0" ry="0"></rect></g><g><text x="375" y="128" class="messageText" style="text-anchor: middle;">调用磁盘读取文件</text><line x1="275" y1="135" x2="475" y2="135" class="messageLine0" stroke-width="2" stroke="black" marker-end="url(#arrowhead)" style="fill: none;"></line></g><g><rect x="470" y="137" fill="#f4f4f4" stroke="#666" width="10" height="33" rx="0" ry="0"></rect></g><g><text x="372.5" y="163" class="messageText" style="text-anchor: middle;">磁盘完成文件读取通知 OS</text><line x1="470" y1="170" x2="275" y2="170" class="messageLine0" stroke-width="2" stroke="black" marker-end="url(#arrowhead)" style="fill: none;"></line></g><g><rect x="270" y="172" fill="#f4f4f4" stroke="#666" width="10" height="79" rx="0" ry="0"></rect></g><g><rect x="300" y="180" fill="#EDF2AE" stroke="#666" width="150" height="36" rx="0" ry="0" class="note"></rect><text x="296" y="204" fill="black" class="noteText"><tspan x="316" fill="black">OS 拷贝数据到内核缓冲区</tspan></text></g><g><text x="175" y="244" class="messageText" style="text-anchor: middle;">OS 拷贝数据到用户缓冲区</text><line x1="270" y1="251" x2="80" y2="251" class="messageLine0" stroke-width="2" stroke="black" marker-end="url(#arrowhead)" style="fill: none;"></line></g><g><rect x="0" y="271" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="75" y="303.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle;"><tspan x="75" dy="0">JVM</tspan></text></g><g><rect x="200" y="271" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="275" y="303.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle;"><tspan x="275" dy="0">OS_Core</tspan></text></g><g><rect x="400" y="271" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="475" y="303.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle;"><tspan x="475" dy="0">Disk</tspan></text></g></svg> </div> <div class="caption"> JVM 读取文件的流程，整个读取过程中 JVM 的线程全程阻塞等待结果 </div> <p>NIO 和 BIO 的核心区别就是，调用 IO 操作的线程不再阻塞。我们使用伪代码的方式说明：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">NonBlockingFileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NonBlockFileInputStream</span><span class="o">(</span><span class="s">"/Users/tiger/test.txt"</span><span class="o">);</span> <span class="c1">// 创建非阻塞读取流，这里是为了说明逻辑，实际上并没有这个类</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">buf</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
<span class="kt">int</span> <span class="n">read</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buf</span><span class="o">);</span> <span class="c1">// 此方法不会阻塞线程，而是根据返回值标识读取结果</span>
<span class="k">while</span> <span class="o">(</span><span class="n">read</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">// 如果没有读到数据，循环</span>
	<span class="n">read</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buf</span><span class="o">);</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">buf</span><span class="o">));</span>
</code></pre></div></div> <p>因为线程没有阻塞，所以该线程就有可能同时处理多个文件的读取了。比如有多个文件输入流，我们就可以这样管理：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">NonBlockingFileInputStream</span><span class="o">&gt;</span> <span class="n">fisList</span> <span class="o">=</span> <span class="n">multiRead</span><span class="o">();</span> <span class="c1">// 假设该方法同时读取多个文件</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">NonBlockingFileInputStream</span> <span class="n">fis</span> <span class="o">:</span> <span class="n">fisList</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">byte</span><span class="o">[]</span> <span class="n">read</span> <span class="o">=</span> <span class="n">read</span><span class="o">(</span><span class="n">fis</span><span class="o">);</span> <span class="c1">// 如果读没有取到内容，返回 null</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">read</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">handleReadResult</span><span class="o">(</span><span class="n">read</span><span class="o">);</span> <span class="c1">// 处理读取内容</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>上面的代码简单说明了如何使用非阻塞读取的方式通过一个线程管理多个读取任务。</p> <div class="jekyll-diagrams diagrams mermaid"> <svg id="mermaid-1686152183911" width="100%" xmlns="http://www.w3.org/2000/svg" height="100%" style="max-width:450px;" viewBox="-50 -10 450 391"><style>#mermaid-1686152183911 .label{font-family:trebuchet ms,verdana,arial;color:#333}#mermaid-1686152183911 .node circle,#mermaid-1686152183911 .node ellipse,#mermaid-1686152183911 .node polygon,#mermaid-1686152183911 .node rect{fill:#ececff;stroke:#9370db;stroke-width:1px}#mermaid-1686152183911 .node.clickable{cursor:pointer}#mermaid-1686152183911 .arrowheadPath{fill:#333}#mermaid-1686152183911 .edgePath .path{stroke:#333;stroke-width:1.5px}#mermaid-1686152183911 .edgeLabel{background-color:#e8e8e8}#mermaid-1686152183911 .cluster rect{fill:#ffffde!important;stroke:#aa3!important;stroke-width:1px!important}#mermaid-1686152183911 .cluster text{fill:#333}#mermaid-1686152183911 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:trebuchet ms,verdana,arial;font-size:12px;background:#ffffde;border:1px solid #aa3;border-radius:2px;pointer-events:none;z-index:100}#mermaid-1686152183911 .actor{stroke:#ccf;fill:#ececff}#mermaid-1686152183911 text.actor{fill:#000;stroke:none}#mermaid-1686152183911 .actor-line{stroke:grey}#mermaid-1686152183911 .messageLine0{marker-end:"url(#arrowhead)"}#mermaid-1686152183911 .messageLine0,#mermaid-1686152183911 .messageLine1{stroke-width:1.5;stroke-dasharray:"2 2";stroke:#333}#mermaid-1686152183911 #arrowhead{fill:#333}#mermaid-1686152183911 #crosshead path{fill:#333!important;stroke:#333!important}#mermaid-1686152183911 .messageText{fill:#333;stroke:none}#mermaid-1686152183911 .labelBox{stroke:#ccf;fill:#ececff}#mermaid-1686152183911 .labelText,#mermaid-1686152183911 .loopText{fill:#000;stroke:none}#mermaid-1686152183911 .loopLine{stroke-width:2;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#ccf}#mermaid-1686152183911 .note{stroke:#aa3;fill:#fff5ad}#mermaid-1686152183911 .noteText{fill:#000;stroke:none;font-family:trebuchet ms,verdana,arial;font-size:14px}#mermaid-1686152183911 .section{stroke:none;opacity:.2}#mermaid-1686152183911 .section0{fill:rgba(102,102,255,.49)}#mermaid-1686152183911 .section2{fill:#fff400}#mermaid-1686152183911 .section1,#mermaid-1686152183911 .section3{fill:#fff;opacity:.2}#mermaid-1686152183911 .sectionTitle0,#mermaid-1686152183911 .sectionTitle1,#mermaid-1686152183911 .sectionTitle2,#mermaid-1686152183911 .sectionTitle3{fill:#333}#mermaid-1686152183911 .sectionTitle{text-anchor:start;font-size:11px;text-height:14px}#mermaid-1686152183911 .grid .tick{stroke:#d3d3d3;opacity:.3;shape-rendering:crispEdges}#mermaid-1686152183911 .grid path{stroke-width:0}#mermaid-1686152183911 .today{fill:none;stroke:red;stroke-width:2px}#mermaid-1686152183911 .task{stroke-width:2}#mermaid-1686152183911 .taskText{text-anchor:middle;font-size:11px}#mermaid-1686152183911 .taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px}#mermaid-1686152183911 .taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}#mermaid-1686152183911 .taskText0,#mermaid-1686152183911 .taskText1,#mermaid-1686152183911 .taskText2,#mermaid-1686152183911 .taskText3{fill:#fff}#mermaid-1686152183911 .task0,#mermaid-1686152183911 .task1,#mermaid-1686152183911 .task2,#mermaid-1686152183911 .task3{fill:#8a90dd;stroke:#534fbc}#mermaid-1686152183911 .taskTextOutside0,#mermaid-1686152183911 .taskTextOutside1,#mermaid-1686152183911 .taskTextOutside2,#mermaid-1686152183911 .taskTextOutside3{fill:#000}#mermaid-1686152183911 .active0,#mermaid-1686152183911 .active1,#mermaid-1686152183911 .active2,#mermaid-1686152183911 .active3{fill:#bfc7ff;stroke:#534fbc}#mermaid-1686152183911 .activeText0,#mermaid-1686152183911 .activeText1,#mermaid-1686152183911 .activeText2,#mermaid-1686152183911 .activeText3{fill:#000!important}#mermaid-1686152183911 .done0,#mermaid-1686152183911 .done1,#mermaid-1686152183911 .done2,#mermaid-1686152183911 .done3{stroke:grey;fill:#d3d3d3;stroke-width:2}#mermaid-1686152183911 .doneText0,#mermaid-1686152183911 .doneText1,#mermaid-1686152183911 .doneText2,#mermaid-1686152183911 .doneText3{fill:#000!important}#mermaid-1686152183911 .crit0,#mermaid-1686152183911 .crit1,#mermaid-1686152183911 .crit2,#mermaid-1686152183911 .crit3{stroke:#f88;fill:red;stroke-width:2}#mermaid-1686152183911 .activeCrit0,#mermaid-1686152183911 .activeCrit1,#mermaid-1686152183911 .activeCrit2,#mermaid-1686152183911 .activeCrit3{stroke:#f88;fill:#bfc7ff;stroke-width:2}#mermaid-1686152183911 .doneCrit0,#mermaid-1686152183911 .doneCrit1,#mermaid-1686152183911 .doneCrit2,#mermaid-1686152183911 .doneCrit3{stroke:#f88;fill:#d3d3d3;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}#mermaid-1686152183911 .activeCritText0,#mermaid-1686152183911 .activeCritText1,#mermaid-1686152183911 .activeCritText2,#mermaid-1686152183911 .activeCritText3,#mermaid-1686152183911 .doneCritText0,#mermaid-1686152183911 .doneCritText1,#mermaid-1686152183911 .doneCritText2,#mermaid-1686152183911 .doneCritText3{fill:#000!important}#mermaid-1686152183911 .titleText{text-anchor:middle;font-size:18px;fill:#000}
#mermaid-1686152183911 g.classGroup text{fill:#9370db;stroke:none;font-family:trebuchet ms,verdana,arial;font-size:10px}#mermaid-1686152183911 g.classGroup rect{fill:#ececff;stroke:#9370db}#mermaid-1686152183911 g.classGroup line{stroke:#9370db;stroke-width:1}#mermaid-1686152183911 .classLabel .box{stroke:none;stroke-width:0;fill:#ececff;opacity:.5}#mermaid-1686152183911 .classLabel .label{fill:#9370db;font-size:10px}#mermaid-1686152183911 .relation{stroke:#9370db;stroke-width:1;fill:none}#mermaid-1686152183911 #compositionEnd,#mermaid-1686152183911 #compositionStart{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-1686152183911 #aggregationEnd,#mermaid-1686152183911 #aggregationStart{fill:#ececff;stroke:#9370db;stroke-width:1}#mermaid-1686152183911 #dependencyEnd,#mermaid-1686152183911 #dependencyStart,#mermaid-1686152183911 #extensionEnd,#mermaid-1686152183911 #extensionStart{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-1686152183911 .branch-label,#mermaid-1686152183911 .commit-id,#mermaid-1686152183911 .commit-msg{fill:#d3d3d3;color:#d3d3d3}</style><style>#mermaid-1686152183911{color:#000;font:normal normal 400 normal 16px / normal "Times New Roman"}</style><g></g><g><line id="actor0" x1="75" y1="5" x2="75" y2="380" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="0" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="75" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle;"><tspan x="75" dy="0">JVM</tspan></text></g><g><line id="actor1" x1="275" y1="5" x2="275" y2="380" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="200" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="275" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle;"><tspan x="275" dy="0">OS_Core</tspan></text></g><defs><marker id="arrowhead" refX="5" refY="2" markerWidth="6" markerHeight="4" orient="auto"><path d="M 0,0 V 4 L6,2 Z"></path></marker></defs><defs><marker id="crosshead" markerWidth="15" markerHeight="8" orient="auto" refX="16" refY="4"><path fill="black" stroke="#000000" stroke-width="1px" d="M 9,2 V 6 L16,4 Z" style="stroke-dasharray: 0, 0;"></path><path fill="none" stroke="#000000" stroke-width="1px" d="M 0,1 L 6,7 M 6,1 L 0,7" style="stroke-dasharray: 0, 0;"></path></marker></defs><g><text x="175" y="143" class="messageText" style="text-anchor: middle;">get read result</text><line x1="75" y1="150" x2="275" y2="150" class="messageLine0" stroke-width="2" stroke="black" marker-end="url(#arrowhead)" style="fill: none;"></line></g><g><text x="175" y="178" class="messageText" style="text-anchor: middle;">null</text><line x1="275" y1="185" x2="75" y2="185" class="messageLine0" stroke-width="2" stroke="black" marker-end="url(#arrowhead)" style="fill: none;"></line></g><g><line x1="65" y1="100" x2="285" y2="100" class="loopLine"></line><line x1="285" y1="100" x2="285" y2="195" class="loopLine"></line><line x1="65" y1="195" x2="285" y2="195" class="loopLine"></line><line x1="65" y1="100" x2="65" y2="195" class="loopLine"></line><polygon points="65,100 115,100 115,113 106.6,120 65,120" class="labelBox"></polygon><text x="72.5" y="115" fill="black" class="labelText"><tspan x="72.5" fill="black">loop</tspan></text><text x="175" y="115" fill="black" class="loopText" style="text-anchor: middle;"><tspan x="175" fill="black">[ 轮询 ]</tspan></text></g><g><text x="175" y="243" class="messageText" style="text-anchor: middle;">get read result</text><line x1="75" y1="250" x2="275" y2="250" class="messageLine0" stroke-width="2" stroke="black" marker-end="url(#arrowhead)" style="fill: none;"></line></g><g><rect x="270" y="252" fill="#f4f4f4" stroke="#666" width="10" height="33" rx="0" ry="0"></rect></g><g><text x="172.5" y="278" class="messageText" style="text-anchor: middle;">byte array</text><line x1="270" y1="285" x2="75" y2="285" class="messageLine0" stroke-width="2" stroke="black" marker-end="url(#arrowhead)" style="fill: none;"></line></g><g><line x1="55" y1="75" x2="295" y2="75" class="loopLine"></line><line x1="295" y1="75" x2="295" y2="295" class="loopLine"></line><line x1="55" y1="295" x2="295" y2="295" class="loopLine"></line><line x1="55" y1="75" x2="55" y2="295" class="loopLine"></line><line x1="55" y1="205" x2="295" y2="205" class="loopLine" style="stroke-dasharray: 3, 3;"></line><polygon points="55,75 105,75 105,88 96.6,95 55,95" class="labelBox"></polygon><text x="62.5" y="90" fill="black" class="labelText"><tspan x="62.5" fill="black">alt</tspan></text><text x="175" y="90" fill="black" class="loopText" style="text-anchor: middle;"><tspan x="175" fill="black">[ 操作系统未完成读取 ]</tspan></text><text x="175" y="220" fill="black" class="loopText" style="text-anchor: middle;"><tspan x="175" fill="black">[ 操作系统完成文件读取 ]</tspan></text></g><g><rect x="0" y="315" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="75" y="347.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle;"><tspan x="75" dy="0">JVM</tspan></text></g><g><rect x="200" y="315" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="275" y="347.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle;"><tspan x="275" dy="0">OS_Core</tspan></text></g></svg> </div> <div class="caption"> 非阻塞读取文件，当前线程一直在运行中 </div> <p>这里有个问题，既然 BIO 已经可以实现 IO 操作，为什么还要推出一套 NIO 体系呢？要理解这个问题，我们需要通过网络 IO 来进行说明，因为 NIO 主要是为了优化网络 IO 模型的。</p> <p>我们通常使用网络 IO 来实现 B/S 和 C/S 架构，就是浏览器和客户端访问网络服务器做数据交互。这些架构有个共同特点：客户端的数量远大于服务器的数量，一台服务器需要支持多个客户端的网络传输。使用传统的 BIO 模型，服务器在从网络 <code class="language-plaintext highlighter-rouge">socket</code> 中读取或写入数据时，当前线程是阻塞的，这时如果有其他客户端也在请求服务器，当前线程无法响应。这肯定是不可接受的。所以使用传统 BIO 模型，服务器端一定是通过多线程的方式支持并发请求。客户端一旦连接服务器，服务器就创建一个线程去单独处理该客户端的请求。但一台服务器能同时运行的线程数量是有限的，因为服务器内存是有限的。并且线程在处理网络 IO 的过程中也会阻塞，也就是说服务器的内存被大量占用，却没有得到高效的利用。这是 BIO 模型的弊端。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/bio-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/bio-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/bio-1400.webp"/> <img src="/assets/img/bio.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> BIO 的服务器线程模型 </div> <p>而 NIO 尝试解决 BIO 的弊端。NIO 在处理 IO 请求时，当前线程不会阻塞，这就可以实现通过一个线程管理多个客户端的 IO 请求，在一定程度上提高了服务器资源的利用率。但我们在上面的 NIO 例子中也会发现一个问题，就是无论当前有没有 IO 请求，线程会一直空转下去，这是对 CPU 资源的浪费。我们可以看一下JVM 是如何通过自己的 NIO 模型解决这个问题的。</p> <h1 id="nio-的核心组件">NIO 的核心组件</h1> <p>NIO 有三大核心组件。分别是 <code class="language-plaintext highlighter-rouge">Selector</code>、<code class="language-plaintext highlighter-rouge">Channel</code> 和 <code class="language-plaintext highlighter-rouge">ByteBuffer</code>。我们分别介绍这些组件的作用。</p> <h2 id="bytebuffer-缓冲区">ByteBuffer 缓冲区</h2> <p>ByteBuffer 顾名思义，就是在 IO 过程中的数据缓冲区，有些类似于我们在上面例子中的字节数组，但 ByteBuffer 封装了很多实用的方法，比字节数组功能更强大。我们先看一下 <code class="language-plaintext highlighter-rouge">ByteBuffer</code> 的类结构：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/byte-buffer-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/byte-buffer-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/byte-buffer-1400.webp"/> <img src="/assets/img/byte-buffer.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>可以看到，<code class="language-plaintext highlighter-rouge">ByteBuffer</code> 是一个抽象类，它有两个实现体系，分别是 <code class="language-plaintext highlighter-rouge">MappedByteBuffer</code> 和 <code class="language-plaintext highlighter-rouge">HeapByteBuffer</code>，其中以 “R” 为后缀的实现类表示只读缓存。从类名我们就可以看出端倪，<code class="language-plaintext highlighter-rouge">HeapByteBuffer</code> 是直接申请在 JVM 堆内存上的缓冲区，而 <code class="language-plaintext highlighter-rouge">MappedByteBuffer</code> 则是映射到系统内存上的缓冲区，被称作“直接缓存”，直接缓存是操作系统的内存空间，需要我们自行管理这部分内存，防止出现内存泄漏。</p> <p>ByteBuffer 是 Buffer 体系下最常用的类。Buffer 还包括其他基本类型的实现，如 <code class="language-plaintext highlighter-rouge">CharBuffer</code>、<code class="language-plaintext highlighter-rouge">DoubleBuffer</code> 等，具体可以参考 JVM 的 API 文档。</p> <p>注意，ByteBuffer 不是线程安全的，多线程编程下需要注意状态的同步控制。</p> <h3 id="buffer-的底层原理">Buffer 的底层原理</h3> <p>Buffer 是所有缓冲区实现类的父类，它定义了一个线性的有限序列，用来存放原始数据类型。Buffer 有三个重要属性，分别是：</p> <ul> <li><code class="language-plaintext highlighter-rouge">capacity</code>。表示当前缓冲区能存放的最大元素数量。缓冲区一旦创建，容量便不会更改。</li> <li><code class="language-plaintext highlighter-rouge">limit</code>。表示当前缓冲区可以读/写的终点索引。范围是 [0, capacity]。</li> <li><code class="language-plaintext highlighter-rouge">position</code>。表示当前缓冲区下一个可以读/写的元素索引。范围是 [0, limit]。</li> </ul> <p>缓冲区有两种操作模式：<code class="language-plaintext highlighter-rouge">读模式(get)</code> 和 <code class="language-plaintext highlighter-rouge">写模式(put)</code>。假设创建一个 8 字节的缓冲区：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ByteBuffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nc">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="mi">8</span><span class="o">);</span>
</code></pre></div></div> <p>我们用图表示一下缓冲区各个状态之间的变化：</p> <h4 id="初始化">初始化</h4> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/buffer-init-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/buffer-init-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/buffer-init-1400.webp"/> <img src="/assets/img/buffer-init.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 初始化缓冲区 </div> <p>初始化完成后字节数组中所有元素的起始值都是 0。<code class="language-plaintext highlighter-rouge">position</code> = 0，<code class="language-plaintext highlighter-rouge">limit</code> = <code class="language-plaintext highlighter-rouge">capacity</code>。</p> <h4 id="写入数据">写入数据</h4> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/buffer-write-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/buffer-write-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/buffer-write-1400.webp"/> <img src="/assets/img/buffer-write.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 向缓冲区写入数据 </div> <p>缓冲区写入部分数据后，<code class="language-plaintext highlighter-rouge">position</code> 向后移动，指向下一个要写入的位置。如果写入的数据超过缓冲区的容量，导致 <code class="language-plaintext highlighter-rouge">position == limit</code>，此时再写入就会抛出 <code class="language-plaintext highlighter-rouge">BufferOverflowException</code> 。</p> <h4 id="切换到读模式">切换到读模式</h4> <p>当缓冲区写入部分数据后，调用缓冲区的 <code class="language-plaintext highlighter-rouge">flip()</code> 方法，将缓冲区转换为读模式。<code class="language-plaintext highlighter-rouge">flip()</code> 方法做的事情很简单，我们直接看源码：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="nc">Buffer</span> <span class="nf">flip</span><span class="o">()</span> <span class="o">{</span>  
    <span class="n">limit</span> <span class="o">=</span> <span class="n">position</span><span class="o">;</span> <span class="c1">// 将 limit 重置为当前 position 的值，表示最多读到这里</span>
    <span class="n">position</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// position 重置为 0，表示从头开始读</span>
    <span class="n">mark</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// 辅助参数，这里不展开</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">;</span> <span class="c1">// 返回当前缓冲区对象</span>
<span class="o">}</span>
</code></pre></div></div> <p>调用 <code class="language-plaintext highlighter-rouge">flip()</code> 方法后缓冲区变为：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/buffer-read-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/buffer-read-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/buffer-read-1400.webp"/> <img src="/assets/img/buffer-read.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 缓冲区转变为读模式 </div> <h4 id="切换到写模式">切换到写模式</h4> <p>当缓冲区的数据读取完之后，调用 <code class="language-plaintext highlighter-rouge">clear()</code> 方法，将缓冲区重置为初始化的状态。</p> <p>当读取了缓冲区部分数据后，如果此时想立即切换到读模式，可以调用 <code class="language-plaintext highlighter-rouge">compact()</code> 方法压缩缓冲区，把已经读取的部分移除，把未读取的部分往前移：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/buffer-compact-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/buffer-compact-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/buffer-compact-1400.webp"/> <img src="/assets/img/buffer-compact.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 压缩缓冲区并进入写模式 </div> <h2 id="channel-通道">Channel 通道</h2> <p><code class="language-plaintext highlighter-rouge">Channel</code> 相当于 NIO 模型中的流，表示 JVM 应用和一个支持 I/O 操作的设备或组件的连接，如硬盘、Socket、文件等。<code class="language-plaintext highlighter-rouge">Channel</code> 支持双向传输，既可以读，也可以写。程序不能直接访问 <code class="language-plaintext highlighter-rouge">Channel</code> 中的数据，需要通过 <code class="language-plaintext highlighter-rouge">Buffer</code> 作为中介。<code class="language-plaintext highlighter-rouge">Channel</code> 还提供了 <code class="language-plaintext highlighter-rouge">map()</code> 方法，支持将“一块”数据直接映射到系统内存中。常见的 <code class="language-plaintext highlighter-rouge">Channel</code> 实现包括：</p> <ul> <li>FileChannel。用于文件读写；</li> <li>SocketChannel &amp; ServerSocketChannel。用于实现 TCP 客户端服务端通信；</li> <li>DatagramChannel。用于实现 UDP 通信；</li> </ul> <p>如下图所示：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/channel-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/channel-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/channel-1400.webp"/> <img src="/assets/img/channel.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>注意类图中的 <code class="language-plaintext highlighter-rouge">SelectableChannel</code> 类，该类表示可以被下面提到的选择器进行管理。<code class="language-plaintext highlighter-rouge">FileChannel</code> 没有继承该类，表示文件相关的 I/O 不支持选择器操作，也就是说不支持非阻塞操作。</p> <p>默认情况下，<code class="language-plaintext highlighter-rouge">Channel</code> 对象都是工作在阻塞模式下的，可以通过下面的方法修改：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SocketChannel</span><span class="o">.</span><span class="na">configureBlocking</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span> <span class="c1">// 指定当前通道为非阻塞模式</span>
</code></pre></div></div> <h2 id="selector-选择器">Selector 选择器</h2> <p><code class="language-plaintext highlighter-rouge">SelectableChannel</code> 对象的多路复用器。选择器可以同时管理多个通道对象，当发生通道关注的事件时，通知对应的通道对象进行处理。</p> <p><code class="language-plaintext highlighter-rouge">SelectableChannel</code> 的子类实现了 <code class="language-plaintext highlighter-rouge">register()</code> 方法，通道调用该方法，即可注册到指定的 <code class="language-plaintext highlighter-rouge">Selector</code> 对象上：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 注册到指定的选择器上
 * @param sel 选择器对象
 * @param ops 通道关注的事件
 * @param att 附件
 * @return SelectionKey 通道的注册结果，对象中包含对应的通道和选择器以及操作方法
 */</span>
<span class="nc">SelectionKey</span> <span class="nc">SelectableChannel</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="nc">Selector</span> <span class="n">sel</span><span class="o">,</span> <span class="kt">int</span> <span class="n">ops</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">att</span><span class="o">);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Selector</code> 支持 4 种事件：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SelectionKey</span><span class="o">.</span><span class="na">OP_READ</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="o">;</span>    <span class="c1">// 读就绪，发生在 SocketChannel 和 DatagramChannel，表示当前通道中有数据了，可以执行读到做</span>
<span class="nc">SelectionKey</span><span class="o">.</span><span class="na">OP_WRITE</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="o">;</span>   <span class="c1">// 写就绪，发生在 SocketChannel 和 DatagramChannel，表示可以向当前通道写入数据</span>
<span class="nc">SelectionKey</span><span class="o">.</span><span class="na">OP_CONNECT</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="o">;</span> <span class="c1">// 连接就绪，发生在 SocketChannel，表示客户端和服务端成功建立连接</span>
<span class="nc">SelectionKey</span><span class="o">.</span><span class="na">OP_ACCEPT</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="o">;</span>  <span class="c1">// 连接就绪，发生在 ServerSocketChanne，表示服务端至少接入了一个客户端，可以通过 accept() 方法获取对应的 SocketChannel 了</span>
</code></pre></div></div> <p>关注事件可以在通道注册时指定，也可以通过 <code class="language-plaintext highlighter-rouge">SelectionKey</code> 对象添加：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SelectionKey</span> <span class="nc">SelectionKey</span><span class="o">.</span><span class="na">interestOps</span><span class="o">(</span><span class="kt">int</span> <span class="n">ops</span><span class="o">);</span>
</code></pre></div></div> <p>我们上面提到过非阻塞 I/O 的一个弊端就是会导致线程空转，浪费 CPU 资源。<code class="language-plaintext highlighter-rouge">Selector</code> 解决了这个问题。<code class="language-plaintext highlighter-rouge">Selector</code> 同时支持阻塞和非阻塞模式获取事件通知：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">selectNow</span><span class="o">();</span> <span class="c1">// 该方法工作在非阻塞模式，无论有没有事件发生，调用该方法会立即返回</span>
<span class="kt">int</span> <span class="nf">select</span><span class="o">();</span> <span class="c1">// 该方法调用后会阻塞，直到有关注的事件发生才会返回</span>
<span class="kt">int</span> <span class="nf">select</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">);</span> <span class="c1">// 该方法可以指定阻塞时间</span>
</code></pre></div></div> <h1 id="nio-的底层原理">NIO 的底层原理</h1> <p>我们首先了解一下操作系统常见的 5 种 I/O 模型。</p> <ol> <li>Blocking I/O 阻塞式 I/O；</li> <li>Non-blocking I/O 非阻塞式 I/O；</li> <li>I/O multiplexing I/O (select and poll) 多路复用；</li> <li>Signal driven I/O (SIGIO) 信号驱动 I/O；</li> <li>Asynchronous I/O (the POXIS aio_functions) 异步 I/O；</li> </ol> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/io-model-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/io-model-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/io-model-1400.webp"/> <img src="/assets/img/io-model.jpeg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>这 5 种 I/O 模型，使用 <code class="language-plaintext highlighter-rouge">同步/异步</code> 、<code class="language-plaintext highlighter-rouge">阻塞/非阻塞</code> 分类：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/io-model2-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/io-model2-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/io-model2-1400.webp"/> <img src="/assets/img/io-model2.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>前面已经介绍过 BIO 和 NIO 的区别，而 Java 的 NIO 模型，实际上就是 <em>多路复用</em>。</p> <p>目前主流的多路复用 I/O 实现主要有四种：<code class="language-plaintext highlighter-rouge">select</code>、<code class="language-plaintext highlighter-rouge">poll</code>、<code class="language-plaintext highlighter-rouge">epoll</code>、<code class="language-plaintext highlighter-rouge">kqueue</code>。下表是它们的一些重要特性和比较：</p> <table> <thead> <tr> <th>IO 模型</th> <th>相对性能</th> <th>关键思路</th> <th>操作系统</th> <th>Java 支持情况</th> </tr> </thead> <tbody> <tr> <td>select</td> <td>较高</td> <td>Reactor</td> <td>Windows/Linux</td> <td>支持，Reactor模式（反应器设计模式）。Linux 操作系统的 kernels 2.4 内核版本之前，默认使用 <code class="language-plaintext highlighter-rouge">select</code>；而目前 windows 下对同步 IO 的支持，都是 <code class="language-plaintext highlighter-rouge">select</code> 模型</td> </tr> <tr> <td>poll</td> <td>较高</td> <td>Reactor</td> <td>Linux</td> <td>Linux 下的 Java NIO 框架，Linux kernels 2.6 内核版本之前使用 <code class="language-plaintext highlighter-rouge">poll</code> 支持。也是使用 Reactor 模式</td> </tr> <tr> <td>epoll</td> <td>高</td> <td>Reactor/Proactor</td> <td>Linux</td> <td>Linux kernels 2.6 内核版本及之后使用 <code class="language-plaintext highlighter-rouge">epoll</code> 进行支持。另外需要注意，由于 Linux 下没有 windows 的 IOCP 技术提供真正的 <code class="language-plaintext highlighter-rouge">异步 IO</code> 支持，所以 Linux 下使用 <code class="language-plaintext highlighter-rouge">epoll</code> 模拟异步 IO</td> </tr> <tr> <td>kqueue</td> <td>高</td> <td>Proactor</td> <td>Linux</td> <td>目前 Java 不支持</td> </tr> </tbody> </table> <p>多路复用技术最适用于“高并发”场景，所谓高并发是指 1 ms 内至少同时有上千个连接请求准备好。其他情况下多路复用技术不能发挥优势。另一方面，使用 Java NIO 进行功能实现，相对于传统 <code class="language-plaintext highlighter-rouge">Socket</code> 实现要复杂一些。在实际应用中，要根据自己的业务需求进行技术选择。</p> <h2 id="java-nio-和-os-的交互">Java NIO 和 OS 的交互</h2> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/java-nio-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/java-nio-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/java-nio-1400.webp"/> <img src="/assets/img/java-nio.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h1 id="参考">参考</h1> <ul> <li><a href="https://learn.lianglianglee.com/%E6%96%87%E7%AB%A0/Java%20IO%20%E4%BD%93%E7%B3%BB%E3%80%81%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%A4%A7%E6%80%BB%E7%BB%93.md">Java IO 体系、线程模型大总结</a></li> <li><a href="https://learn.lianglianglee.com/%E6%96%87%E7%AB%A0/Java%20NIO%E6%B5%85%E6%9E%90.md">Java NIO 浅析</a></li> <li><a href="https://pdai.tech/md/java/io/java-io-nio-select-epoll.html">IO 多路复用详解</a></li> </ul>]]></content><author><name></name></author><category term="Java"/><category term="IO"/><category term="Java"/><category term="NIO"/><summary type="html"><![CDATA[Java NIO 概念和使用]]></summary></entry><entry><title type="html">RPC 框架初探</title><link href="https://wzm001.github.io//blog/2023/rpc/" rel="alternate" type="text/html" title="RPC 框架初探"/><published>2023-04-13T00:45:16+00:00</published><updated>2023-04-13T00:45:16+00:00</updated><id>https://wzm001.github.io//blog/2023/rpc</id><content type="html" xml:base="https://wzm001.github.io//blog/2023/rpc/"><![CDATA[<h1 id="什么是-rpc">什么是 RPC</h1> <p>RPC(Remote Procedure Call)，远程服务调用，是分布式系统绕不开的话题。RPC 是一个大的概念，这里我们缩小一下讨论的范围，只关注多个服务（进程）之间通过网络进行通信的问题。</p> <p>我们通常意义上理解的 RPC，一般公认是施乐公司（Xerox PARC）于 1981 年在论文 <a href="http://www.bitsavers.org/pdf/xerox/parc/techReports/CSL-81-9_Remote_Procedure_Call.pdf">Remote Procedure Call</a> 提出的：</p> <blockquote> <p>Remote procedure call is the synchronous language-level transfer of control between programs in disjoint address spaces whose primary communication medium is a narrow channel.</p> <p><em>远程服务调用</em> 是指位于互不重合的内存地址空间中的两个程序，在语言层面上，以 <strong>同步</strong> 的方式使用 <strong>带宽有限</strong> 的信道来传输程序控制信息。</p> </blockquote> <p>虽然市面上的 RPC 框架有很多，但在功能上基本大同小异，所有 RPC 框架都需要关注三个基本问题：</p> <ul> <li><strong>如何表示数据</strong> ：这里的数据包含传输控制的元数据，传递方法的参数，以及方法的返回值。因为信息传递发生在网络中，两端的服务势必需要约定好一个统一的序列化/反序列化协议；如 <code class="language-plaintext highlighter-rouge">gRPC</code> 的 <code class="language-plaintext highlighter-rouge">Protocol Buffers</code> 协议、XML、JSON 等；</li> <li><strong>如何传递数据</strong> ：信息经过序列化之后，如何通过网络，在两个服务的 EndPoint 之间相互操作，交换数据。这里“交换数据”通常指的是应用层协议，实际传输一般是基于标准的 TCP、UDP 等传输层协议实现。两个服务的交互不仅仅是传递一个序列化流来表示参数和结果就行，在此之外还有许多额外信息，比如异常、超时、安全、认证、授权、事务等等，都需要考虑如何传递；相当于 RPC 事先约定的控制协议；</li> <li><strong>如何确定方法</strong> ：因为调用的是语言层面的方法，这里就需要服务双方约定一个规范，针对“如何表示一个方法”、“如何找到一个方法”的问题提出一个 <em>跨语言</em> 的规范，这个通常称为 <code class="language-plaintext highlighter-rouge">IDL(Interface Definition Language)</code>，IDL 有不同的实现，如 <code class="language-plaintext highlighter-rouge">gRPC</code> 使用 <code class="language-plaintext highlighter-rouge">Protocol Buffers</code> 作为 IDL。</li> </ul> <p>随着分布式架构在最近几年的兴起，RPC 框架除了在满足这三个基本问题的基础上，逐渐朝着更高层次（不仅负责调用远程服务，还管理远程服务）和插件化的方向发展。下面我们就挑选几个比较流行的 RPC 框架，进行简单的对比。</p> <h1 id="dubbo">Dubbo</h1> <p><a href="https://dubbo.apache.org/zh-cn/">Dubbo</a> 是阿里实现的一个 RPC 框架，后来捐献给 Apache 软件基金会，称为 Apache 的顶级项目。Dubbo 在提供 RPC 功能的基础上，还添加了服务监控和治理的功能，如服务发现、动态配置、负载均衡、流量路由等，官方目前对 Dubbo 的定义是一款 <em>服务开发框架</em>，因其兼顾了数据层面的 RPC 调用和服务层面的监控管理。</p> <p>Dubbo 提供的核心功能包括：</p> <ul> <li><strong>RPC 服务定义、开发范式</strong> ：支持通过 IDL 定义服务，也支持编程语言特有的服务开发定义方式，如通过 Java Interface 定义服务；</li> <li><strong>RPC 服务发布与调用 API</strong> ：支持同步、异步、Reactive Streaming 等服务调用编程模式，还支持请求上下文 API、设置超时时间等；</li> <li><strong>服务治理策略、流程与适配方式</strong> ：在服务框架层面，Dubbo 定义了服务地址发现、负载均衡策略、基于规则的流量路由、Metrics 指标采集等服务治理抽象，并适配特定的产品实现；</li> </ul> <p>Dubbo 目前的发展，已经脱离了 RPC 框架的范畴，向 Spring Cloud 靠拢了。</p> <h1 id="grpc">gRPC</h1> <p><a href="https://grpc.io/">gRPC</a> 是 Google 开源的一个 RPC 框架，使用 <code class="language-plaintext highlighter-rouge">HTTP/2</code> 协议传输，使用 <code class="language-plaintext highlighter-rouge">Protocol Buffers</code> 作为 IDL 和序列化协议。</p> <p>gRPC 是一个高效的 RPC 框架，相比于其他 RPC 框架，gRPC 具有简单、高效、跨语言的特点：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/grpc-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/grpc-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/grpc-1400.webp"/> <img src="/assets/img/grpc.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>gRPC 支持 4 种模式的 RPC 场景：</p> <ul> <li>常规 RPC。客户端发起调用，服务端返回结果： <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rpc SayHello(HelloRequest) returns (HelloResponse);
</code></pre></div> </div> </li> <li>服务端流式 RPC。客户端发起调用，服务端返回数据流，客户端从返回的流中读取，直到数据读完为止。gRPC 保证单个 RPC 调用中消息有序： <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);
</code></pre></div> </div> </li> <li>客户端流式 RPC。客户端发起调用，向服务端写入一系列消息。当客户端完成消息写入后，等待服务端返回响应。gRPC 保证单个 RPC 调用中消息有序： <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);
</code></pre></div> </div> </li> <li>双向流式 RPC。客户端写入流，服务端返回流。这两个流独立运行，因此服务端可以控制读写的节奏。gRPC 保证两个流中消息有序： <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);
</code></pre></div> </div> </li> </ul> <h1 id="thrift">Thrift</h1> <p><a href="https://thrift.apache.org/">Thrift</a> 是 Facebook 开源的 RPC 框架。Thrift 架构设计和 gRPC 类似，也是先编写 IDL 文件，然后使用编译器生成对应语言的代码模块（stub）。最后业务调用即可。</p> <p>Thrift 和 gRPC 的性能表现网上有很多资料，这里就不赘述了。但我简单看了一下两个框架的官方文档，感觉 Thrift 的文档相对维护得差一些。</p> <h1 id="总结">总结</h1> <p>本文只是针对 RPC 做了一些概念上的整理，不涉及具体产品的技术实现。感觉目前市面上常见的 RPC 框架，基本可以划分为两类：一类是“大而全”的，这类框架在 RPC 的业务场景下向外拓展了很多功能，以 Dubbo 为代表，成员有新浪的 Motan 等；另一类是“小而精”的，这类框架专注于 RPC 的核心功能，以 gRPC、Thrift 为代表。</p> <h1 id="参考">参考</h1> <ul> <li><a href="https://icyfenix.cn/architect-perspective/general-architecture/api-style/rpc.html">远程服务调用</a></li> </ul>]]></content><author><name></name></author><category term="框架"/><category term="微服务"/><category term="RPC"/><summary type="html"><![CDATA[Dubbo, gRPC, Thrift 对比]]></summary></entry><entry><title type="html">Spring 框架的整体认识</title><link href="https://wzm001.github.io//blog/2023/spring/" rel="alternate" type="text/html" title="Spring 框架的整体认识"/><published>2023-04-12T00:45:16+00:00</published><updated>2023-04-12T00:45:16+00:00</updated><id>https://wzm001.github.io//blog/2023/spring</id><content type="html" xml:base="https://wzm001.github.io//blog/2023/spring/"><![CDATA[<p>Spring 全家桶是目前 Java 开发必不可少的工具，随着开发技术的不断演进，Spring 框架也变得越来越复杂。今天简单梳理一下 Spring 框架的概念，目的是建立起一个更高维度的认识，这里不涉及具体的技术实现和代码逻辑。</p> <p>我们打开 Spring 的<a href="https://spring.io/">官网</a>，看到官方对 Spring 的介绍是：</p> <blockquote> <p>Spring makes programming Java quicker, easier, and safer for everybody. Spring’s focus on speed, simplicity, and productivity has made it the <a href="https://snyk.io/blog/jvm-ecosystem-report-2018-platform-application/">world’s most popular</a> Java framework.</p> </blockquote> <p>官网还列出了 Spring 全家桶的主要功能：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/spring-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/spring-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/spring-1400.webp"/> <img src="/assets/img/spring.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> What Spring can do? </div> <p>可以看到，Spring 已经发展成为一个生态，覆盖了后端开发的方方面面。下面我们从 Spring 生态中最常用的三个框架入手，介绍 Spring 解决了哪些问题。</p> <h1 id="spring-framework">Spring Framework</h1> <p>Spring Framework 是 Spring 生态的基础。Spring 框架分为不同的模块（modules），应用可以任意选择需要的模块整合进自己的代码。下图是 Spring Framework 的模块概览：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/spring-overview-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/spring-overview-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/spring-overview-1400.webp"/> <img src="/assets/img/spring-overview.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Spring Framework 概览。Spring 框架一直在发展，建议从官方文档查看最新资料 </div> <p>从图中我们可以看出，Spring 框架的核心 <code class="language-plaintext highlighter-rouge">core</code> 模块是所有功能都需要依赖的，<code class="language-plaintext highlighter-rouge">spring-core</code> 模块主要提供了最基础的 <code class="language-plaintext highlighter-rouge">IoC</code> 容器，在此基础上 Spring 扩展大多数应用都会使用的公共模块，包括 <code class="language-plaintext highlighter-rouge">AOP</code> ，负责支持切面编程；Message，负责支持事件驱动等。Data Access 模块负责封装数据访问相关的功能，包括整合 ORM 框架，事务处理等；Web 模块负责处理 Web 开发相关的功能，提供了 <code class="language-plaintext highlighter-rouge">Spring MVC</code> 框架支持传统的同步 web 服务，和 <code class="language-plaintext highlighter-rouge">Spring WebFlux</code> 框架支持异步响应式编程。</p> <p>从 Spring Framework 的模块来看，Spring Framework 涵盖了 Java 企业级应用开发的大部分功能模块。 它不关注开发中某块具体功能如何实现，它的定位是一个 Java 应用开发的大框架，用来协调应用各部分的工作。做个不怎么合适的对比，Spring 框架在单体应用中扮演的角色就像 Zookeeper 在分布式应用中扮演的角色。最核心的作用是 <em>协调</em>。Spring 协调的是各个具体功能模块，Zookeeper 协调的是各个具体的微服务。</p> <p>Spring 框架如何实现协调的功能呢？最重要的技术就是 <em>控制反转</em>，也叫 <em>依赖注入</em>。这两个说的其实是一件事情，控制反转是一种设计思想，依赖注入是这种思想的一个实现。Spring 通过 <code class="language-plaintext highlighter-rouge">IoC</code> 容器协调各模块的工作。在 Spring 的代码中，<code class="language-plaintext highlighter-rouge">IoC</code> 容器被称为 <code class="language-plaintext highlighter-rouge">ApplicationContext</code>，业务上下文，也说明了其设计目的是统一协调整个业务。</p> <p>Spring 框架另一个重要的概念是 <code class="language-plaintext highlighter-rouge">AOP (Aspect Oriented Programming)</code>，面向切面编程。这是一种设计思想。<code class="language-plaintext highlighter-rouge">OOP</code> 和 <code class="language-plaintext highlighter-rouge">AOP</code> 都是为了解耦，编写出更清晰可维护的代码。<code class="language-plaintext highlighter-rouge">OOP</code> 关注的是业务功能层面的封装，纵向解决类和方法层面的设计。<code class="language-plaintext highlighter-rouge">AOP</code> 关注的是公用业务的设计，从横向解决代码重复和耦合的问题。Spring 通过 JDK 代理和 AspectJ 代理支持 AOP。</p> <p>Spring Framework 是 J2EE 的轻量级替代品，它提供了很多方便的功能：</p> <ol> <li>IoC 容器将对象之间的依赖关系交给 Spring 框架管理，降低各个组件之间的耦合性；</li> <li>提供了很多公共服务，如事务管理、Message 等；</li> <li>对 AOP 有很好的支持，方便切面编程；</li> <li>对主流的框架提供了很好的集成支持，如 Hibernate、JPA等；</li> <li>DI 机制降低了业务对象替换的复杂性；</li> <li>低侵入，对业务代码污染极低；</li> <li>高度开放性，不强制依赖 Spring，开发者可以自由选择 Spring 的部分功能模块；</li> </ol> <h1 id="spring-boot">Spring Boot</h1> <p>有了 Spring Framework，为什么还要推出 Spring Boot？这两者有什么区别？要回答这个问题，我们首先看一下 Spring Framework 解决了什么问题，没有解决什么问题。</p> <p>Spring 框架大大提高了开发的便利性，但人们逐渐发现，Spring 整合其他框架的过程中，产生了大量的配置文件。我们以开发普通的 web 应用为例，看看需要处理多少配置文件：</p> <ul> <li>Spring IoC 容器配置文件和 AOP 配置；</li> <li>数据层 ORM 框架配置，如 MyBatis 或 Hibernate 的配置；</li> <li>web 层的配置，如 Spring MVC 的配置；</li> <li>servlet 的配置；</li> <li>日志配置；</li> <li>……</li> </ul> <p>面向对象编程变成了面向配置编程。每次启动一个项目，都要编写大量配置文件，耗费大量的时间。虽然催生了很多脚手架项目，但维护起来总是不太方便的。</p> <p>另外，由于应用整合了许多框架，各个框架对 Spring 又有不同程度的依赖，有些支持高版本的 Spring，有些支持低版本的 Spring，开发人员需要逐一确认依赖是否有冲突，费时费力。</p> <p>基于这些问题，Spring Boot 应运而生了。Spring Boot 的特点就是：</p> <ol> <li>开箱即用。无需处理繁琐的配置和混乱的依赖；</li> <li>灵活配置。Spring Boot 自动整合了大量的开源框架，并且设定好了默认配置。开发人员也可以灵活修改；</li> <li>提供了一些大型项目中常见的非功能特性，如嵌入式服务器、安全、指标、健康监测、外部配置等；</li> </ol> <p>Spring Boot 的核心功能有两个：</p> <ul> <li><em>起步依赖</em>。将具有某种功能的依赖打包到一起，并提供一些默认配置，开发人员只需要关注少量核心配置即可使用，极大地减少了开发的成本。</li> <li><em>自动配置</em>。Spring Boot 内部实现了很多配置策略，在程序启动时，Spring Boot 根据各种条件和策略决定使用哪些配置，目的还是减少开发人员的成本；</li> </ul> <p>从这里我们可以看出，Spring Boot 和 Spring Framework 的关注点不一样，这两者其实没有什么可比性。Spring Boot 是在 Spring Framework 的基础上，添加了一些应用层面的功能，解决开发人员的痛点。我们在 Spring Framework 章节里提到，它的核心作用就是协调，但它协调的代价就是你需要实现提供大量的配置告诉 Spring 怎么做。而 Spring Boot 则更近一步，变成了 <em>自动协调</em>，它遵循 <code class="language-plaintext highlighter-rouge">约定大于配置</code> 的理念，自动为其他模块添加相关配置。</p> <p>Spring Boot 整合了相当多的组件，几乎涵盖了 web 开发和微服务开发的所有场景。具体可以看一下官网的<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/">介绍</a>。</p> <h1 id="spring-cloud">Spring Cloud</h1> <p><a href="https://spring.io/cloud">Spring Cloud</a> 关注的是分布式系统中各个服务之间的协调。</p> <p>相比于单体服务关注的是服务内部各个模块之间的协调，分布式系统的核心的关注点是各个微服务之间如何有效协调沟通，统一提供一套高可用的整体服务。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/spring-cloud-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/spring-cloud-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/spring-cloud-1400.webp"/> <img src="/assets/img/spring-cloud.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Spring Cloud 架构 </div> <p>Spring Cloud 整合了一大批业内知名的微服务开发组件，其中主要包括：</p> <table> <thead> <tr> <th>模块</th> <th>项目</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td>配置中心</td> <td>Spring Cloud Config, Spring Cloud Consul, Spring Cloud Alibaba Nacos</td> <td>使用 git 集中管理外部配置</td> </tr> <tr> <td>服务发现</td> <td>Netflix Eureka, Spring Cloud Spring Cloud Zookeeper, Etcd</td> <td>默认使用 Netflix Eureka 支持</td> </tr> <tr> <td>服务路由/负载均衡</td> <td>Netflix Ribbon, Spring Cloud Loadbalancer</td> <td> </td> </tr> <tr> <td>消息总线</td> <td>Spring Cloud Bus</td> <td>集成了 RabbitMQ 和 Kafka</td> </tr> <tr> <td>API 网关</td> <td>Netflix Zuul, Spring Cloud Gateway</td> <td> </td> </tr> <tr> <td>服务治理</td> <td>Netflix Hystrix, Sentinel, Resilience4j</td> <td> </td> </tr> <tr> <td><a href="https://www.openservicebrokerapi.org/">OSBAPI</a></td> <td>Spring Cloud Open Service Broker</td> <td> </td> </tr> </tbody> </table> <p>Spring Cloud 把分布式系统各个环节抽象成一个节点进行封装，允许开发人员灵活切换实现。</p> <h1 id="总结">总结</h1> <p>这三个组件介绍完，我想可以提炼出 Spring 贯穿始终的设计思想了：Spring 致力于提供一套解决方案，适用于后端软件开发的各个层面。 Spring Framework 负责协调服务内部各个对象间的关系；Spring Boot 更近一步，站在对象组成的框架层面，负责协调各个框架灵活协作；Spring Cloud 再进一步，站在各个服务组成的分布式系统层面，负责协调各个服务之间的协作和管理。</p> <p>这三个框架层层递进，在功能上各有关注点，互不冲突，组成了 Spring 的整个生态圈。</p>]]></content><author><name></name></author><category term="框架"/><category term="Spring"/><summary type="html"><![CDATA[Spring、Spring Boot、Spring Cloud 有什么区别]]></summary></entry><entry><title type="html">Kafka 介绍</title><link href="https://wzm001.github.io//blog/2023/kafka/" rel="alternate" type="text/html" title="Kafka 介绍"/><published>2023-04-10T00:45:16+00:00</published><updated>2023-04-10T00:45:16+00:00</updated><id>https://wzm001.github.io//blog/2023/kafka</id><content type="html" xml:base="https://wzm001.github.io//blog/2023/kafka/"><![CDATA[<p><a href="https://kafka.apache.org/">Kafka</a> 是目前除 RabbitMQ 之外另一个使用广泛的消息队列（RocketMQ 在基本架构上借鉴了 Kafka）。Kafka 采用了和 RabbitMQ 完全不同的实现方式，相比 RabbitMQ， Kafka 提供了更高的吞吐量和完善的高可用机制。</p> <p>Kafka 其实并不算是传统意义上的 MQ，它对 MQ 的支持是它功能的一个子集。相比于传统意义上的 MQ 系统，Kafka 更专注于高效地 <em>传递和转换</em> 消息，更像是一个<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/01%20%20%E6%B6%88%E6%81%AF%E5%BC%95%E6%93%8E%E7%B3%BB%E7%BB%9FABC.md">消息引擎</a>。</p> <p>Kafka 的一些核心概念：</p> <h3 id="topic-主题">Topic 主题</h3> <p>主题用于分类消息，每个消息都有一个特定的主题，主题使用 name 进行区分。下游消费者订阅不同的主题，获取不同类型的消息。</p> <h3 id="partition-分区">Partition 分区</h3> <p>分区用于保存消息。每个主题至少包含一个分区，通常是包含多个分区，序号从 0 开始。分区可以跨服务器，因此分区能显著提高 Kafka 的吞吐量。主题在逻辑层面区分消息，分区则是在物理层面保存消息。分区底层还会细分为 Segment，分段用于优化分区的保存逻辑，防止分区保存的消息太大，影响读取和清理的性能。分段在客户端层面是透明的；</p> <p>分区支持多副本。一个主分区可以配置多个从分区，从分区负责主动备份主分区的数据，实现故障转移。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/kafka-partition.webp-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/kafka-partition.webp-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/kafka-partition.webp-1400.webp"/> <img src="/assets/img/kafka-partition.webp" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h3 id="event-or-message-消息">Event Or Message 消息</h3> <p>消息是业务产生的数据。Kafka 的消息主要包含以下内容：</p> <ul> <li>Key：消息键。Kafka 用 key 来确定消息保存到哪个分区。如果 key 为 null，Kafka 就使用轮询的方式保存消息到不同的分区，否则就根据 Hash 算法计算分区位置。</li> <li>Value：消息体。业务数据，通常经过了压缩；</li> <li>Timestamp：时间戳。消息创建的时间，通常是客户端自动生成，也可以手动指定；</li> <li>Compression type：压缩类型。标记消息体的压缩算法，如 <code class="language-plaintext highlighter-rouge">gzip</code>、<code class="language-plaintext highlighter-rouge">lz4</code>、<code class="language-plaintext highlighter-rouge">snappy</code>、<code class="language-plaintext highlighter-rouge">zstd</code> 或 <code class="language-plaintext highlighter-rouge">none</code>；</li> <li>Headers：消息头，通常指定一些额外信息，可以为空；</li> <li>Topic &amp; Partition number &amp; Offset id：消息一旦写入 Kafka，就会自动带上这三个参数。这三个参数用来唯一定位一条消息；</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/kafka-msg.webp-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/kafka-msg.webp-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/kafka-msg.webp-1400.webp"/> <img src="/assets/img/kafka-msg.webp" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h3 id="offset-偏移量">Offset 偏移量</h3> <p>偏移量用来标记消息在分区中的位置。偏移量是一个从 0 开始递增的数字。</p> <h3 id="broker-服务实例">Broker 服务实例</h3> <p>Broker 是一台运行着 Kafka 服务的服务器。Kafka 集群包含多个 Broker，每个 Broker 包含一些主题和分区。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/kafka-cluster-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/kafka-cluster-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/kafka-cluster-1400.webp"/> <img src="/assets/img/kafka-cluster.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h3 id="consumer-group-消费者组">Consumer Group 消费者组</h3> <p><a href="https://www.conduktor.io/kafka/kafka-consumer-groups-and-consumer-offsets/">消费者</a> 组是 Kafka 用于支持点对点模式引入的概念。一个消费者组下面包含多个 consumer，这些 consumer 都消费同一个主题下的消息，不同的 consumer 消费不同的 partition。每个 partition 只能被一个 consumer 消费，但一个 consumer 可以消费多个 partition，该机制确保 Topic 下的每条消息只能被 Consumer group 中的一个消费者消费。（但可以被多个消费者组消费）</p> <p>如果主题下面的分区数大于消费者组下面的服务实例，那么有些消费者就会消费多个分区的消息。如果两者正好相等，那么每个消费者消费一个分区。如果分区数小于消费者数，那么有些消费者就无法消费，只有等到其他消费者宕机或网络故障导致消费失败后，其他消费者才能顶替原来的消费者进行消费。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/consumer-group-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/consumer-group-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/consumer-group-1400.webp"/> <img src="/assets/img/consumer-group.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h2 id="kafka-高性能的原因">Kafka 高性能的原因</h2> <p>Kafka 最大的特点就是其超高的吞吐量，RabbitMQ 的吞吐量是万级，Kafka 吞吐量在十万级。这主要归功于 Kafka 独特的设计，主要有以下几点：</p> <h3 id="磁盘顺序读写">磁盘顺序读写</h3> <p>磁盘的顺序读写性能比随机读写高出许多。有机构专门做过<a href="https://queue.acm.org/detail.cfm?id=1563874">研究</a> ：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/disk-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/disk-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/disk-1400.webp"/> <img src="/assets/img/disk.jpeg" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Kafka 就是利用了磁盘顺序读写的特性，在 Kafka 底层，消息是保存在 partition 文件中的。为了避免大文件读写，Kafka 将 partition 文件细分为 segment 小文件，每次保存消息都是 <em>追加</em> 到对应文件末尾，而不是随机写入，这使得 Kafka 写入的吞吐量得到显著提高。</p> <p>但这种方式有一个缺陷，就是不能删除数据。因此 Kafka 是不会立即删除消费成功的消息的，它会把所有消息保存下来，消费端根据 Topic 的 offset 数据来读取消息，因此消费端可以根据需要决定从哪里开始读取。</p> <p>Kafka 后台可以配置策略，依据消息时间戳或者文件大小删除旧数据。</p> <h3 id="page-cache">Page Cache</h3> <p>为了优化读写性能， Kafka 利用了操作系统本身的 Page Cache，就是直接利用堆外内存。</p> <h3 id="零拷贝">零拷贝</h3> <p>TODO</p> <h2 id="kafka-的高可用架构">Kafka 的高可用架构</h2> <p>在 2.8.0 版本之前，Kafka 必须绑定 Zookeeter 启动，Zookeeter 负责存储 Kafka 集群的元数据。在 2.8.0 之后， Kafka 移除了对 Zookeeter 的强依赖，集群自身即可管理相关的数据。</p> <blockquote> <p>参考：</p> <ol> <li><a href="https://www.conduktor.io/kafka/kafka-kraft-mode/">Kafka KRaft Mode</a></li> <li><a href="https://www.conduktor.io/kafka/zookeeper-with-kafka/">Zookeeper with Kafka</a></li> <li><a href="https://gitbook.cn/books/5ae1e77197c22f130e67ec4e/index.html">深入浅出理解基于 Kafka 和 ZooKeeper 的分布式消息队列</a></li> <li><a href="https://www.freecodecamp.org/news/apache-kafka-handbook/#consumer-groups-in-kafka">The Apache Kafka Handbook – How to Get Started Using Kafka</a></li> </ol> </blockquote>]]></content><author><name></name></author><category term="MQ"/><category term="微服务"/><category term="MQ"/><category term="Kafka"/><summary type="html"><![CDATA[介绍 Kafka 的架构特点和使用场景]]></summary></entry></feed>