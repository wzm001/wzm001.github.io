---
layout: distill
title: 消息队列的基本概念
date: 2023-04-01 10:15:00+0800
description: 消息队列概念梳理
tags: MQ
categories: Database MQ
giscus_comments: true

toc:
  - name: 什么是消息队列
  - name: 为什么引入消息队列
  - name: 消息队列的使用场景
  - name: 消息队列关注的功能
---

# 什么是消息队列

本文提到的*消息队列（Message Queue，也称为 Message Broker）*，是一种广泛使用的分布式消息中间件。可以把消息队列看作是一种特殊场景下使用的数据库，只支持有限的数据存取操作（入队列和出队列），本质上，消息队列和数据库、Redis、ES 等数据系统没有区别，只是侧重点和使用场景不同而已。

那么消息队列和传统的数据库系统相比，有什么区别呢？

1. 数据存取方式不同。数据库系统支持完整的 SQL 语言操作数据，可以实现复杂的结构化查询。而消息队列只使用队列来组织数据，存取操作也仅仅支持简单的入队和出队操作；
2. 存放的数据性质不同。正如“消息队列”这个名称的含义，消息队列存放的数据是消息，具有“阅后即焚”的特点，虽然消息队列也有持久化的概念，但侧重点不一样，消息队列的持久化是为了保证消息不丢失，系统不需要像数据库一样花费大量的精力去处理数据的持久化逻辑；
3. 吞吐量不同。可以理解消息队列是一个功能受限的数据库，正因为消息队列精简了很多不必要的逻辑，所以它可以获得更好的性能表现，体现在吞吐量上，消息队列的吞吐量要超过传统数据库一个量级（在常见的服务器环境下，MySQL 最大 QPS 大概是 8000，RabbitMQ 的吞吐量大概在 6w/s，Kafka 最大吞吐量高达 17w/s）；
4. 功能侧重点不同。数据库侧重于查询，MQ 则侧重于交换消息。数据库的作用类似于仓库，MQ 的作用类似于管道。

# 为什么引入消息队列

消息队列的三个作用：*异步、解耦、削峰*。

## 异步

异步的作用是提高响应时间，增加系统吞吐量。在一个接口中有许多业务逻辑，如果某个业务不需要当前立即完成且耗时较长，就可以考虑使用异步方式实现。

举个例子，在 ESOP 系统中有许多业务需要给用户发送邮件。例如授予生效功能，当授予生效完成后，需要给员工发送一份通知邮件，如果使用同步方式处理，调用逻辑大概是这样的：
<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/img/sync.png" class="img-fluid rounded z-depth-1"%}
    </div>
</div>
<div class="caption">
    同步方式
</div>

接口的响应时间是 授予生效时间 + 发送通知 的时间，发送通知是个网络请求，会严重拉低接口整体的响应时间。并且邮件通知也不是必须在授予生效后就立即需要完成的操作，因此可以考虑异步调用邮件通知：
<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/img/async.png" class="img-fluid rounded z-depth-1"%}
    </div>
</div>
<div class="caption">
    异步方式
</div>

改为异步调用后，授予生效的整体业务功能不受影响，并且响应时间也有了很大的提升。

## 解耦

解耦的作用是减少服务之间的相互依赖，防止一个服务改动影响了其他关联的服务。设计出低耦合的服务是所有架构师必须考虑的目标，因为耦合度高的系统维护起来非常困难。

回到 ESOP 的例子，授予生效关联了许多下游业务，例如发送邮件通知、生成成熟日志、更新资产信息等。如果这些操作都由授予生效的接口发起，那么各模块间的耦合度就非常高，一旦改动就牵一发而动全身。我们用伪代码说明：
```java
public void effectGrant(GrantModel grant) {
    // 处理授予生效的业务逻辑
    // ......
    // 开始通知下游业务
    // 1. 发送邮件
    asyncSendEmail(grant);
    // 2. 生成成熟日志
    generateMatureLog(grant);
    // 3. 更新资产信息
    updateAssets(grant);
    // ......
    return;
}
```
可以看到，授予生效的接口中包含了大量不属于本业务的代码。并且如果有新的下游服务需要依赖生效接口，这个接口还需要进行修改，这种处理方式是不推荐的。

如果我们引入 MQ 进行业务解耦，则对应的接口伪代码就变成：
```java
public void effectGrant(GrantModel grant) {
    // 处理授予生效的业务逻辑
    // ......
    // 通知下游业务
    sendMsg2MQ(GrantEvent.EFFECTED, grant);
    return;
}
```
可以看到，代码整洁了许多。并且即使有新的下游业务需要接入，这里也不需要修改任何代码。

## 削峰

削峰的作用是为了缓冲突发流量，防止下游服务被爆增的流量打垮。

假如上游服务 A 每秒可以处理 100 个请求，下游服务 B 每秒只能处理 50 个请求，在平时流量不大的情况下，两个服务相安无事，但如果某一时间段的突发流量暴增，超过了下游服务的处理能力，下游服务就可能直接崩溃：
<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/img/crash.png" class="img-fluid rounded z-depth-1"%}
    </div>
</div>
<div class="caption">
    上游请求超过下游处理能力导致下游服务崩溃
</div>

如果上下游服务中间接入消息队列，消息队列就像一个蓄水池，缓冲了上游的请求，让下游服务可以按照自身能力处理业务：
<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/img/mq-cache.png" class="img-fluid rounded z-depth-1"%}
    </div>
</div>
<div class="caption">
    MQ 起到流量缓冲的作用
</div>

消息队列给系统带来了明显的好处，但同时也使得系统变得复杂，引入新的中间件，增加了系统不稳定的概率，也增加了维护成本。

# 消息队列的使用场景

消息队列主要的使用场景有三种：点对点模式、发布订阅模式和请求响应模式。

注意这里隐含的条件：*一个队列中的消息只能被消费一次*。（RabbitMQ 是这样的设计理念，但 Kafka 并没有这种要求）

## 点对点

点对点模式指的是消息从生产者出发，最终被某一个消费者消费。这是最常见的通信方式，通常用于任务队列。生产者将一些耗时大的任务发布到消息队列，消费者集群中的某个实例获取到消息进行任务处理。

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/img/p2p.png" class="img-fluid rounded z-depth-1"%}
    </div>
</div>
<div class="caption">
    点对点模式，特点是只有一个队列
</div>

任务队列是 MQ 重要的应用场景，这里有需要需要注意的细节，例如：
- 如何保证消息不被重复消费；
- 如何保证不丢失消息；
- 如何在多个消费者之间做负载均衡；
- 消息长时间积压怎么处理；

等等。这些问题都需要在设计系统之初就考虑清楚。

## 发布/订阅

这种模式的特点是消息会被多个消费者接收。通常用于事件驱动的系统。下游业务订阅感兴趣的上游业务事件，然后做后续的处理。

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/img/pub-sub.png" class="img-fluid rounded z-depth-1"%}
    </div>
</div>
<div class="caption">
    发布/订阅模式，特点是一个消息发送到多个队列中
</div>

通常发布/订阅模式和点对点模式是配套出现的，从系统整体看是发布/订阅，从某个事件的消费上看，又是点对点模式。因此点对点模式中需要注意的问题，这里也都需要考虑。

## 请求/响应

类似于通过 MQ 实现 RPC 的功能。生产者发送消息后，会等待消费者返回的响应结果。整个过程是异步的，可以理解为消费者通过回调通知生产者。

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/img/req-res.png" class="img-fluid rounded z-depth-1"%}
    </div>
</div>
<div class="caption">
    请求/响应模式，特点是两个服务互为生产者和消费者
</div>

这种模式的应用场景在功能上和 RPC 框架类似，但 RPC 框架是直接将两个服务连接起来，而 MQ 的方式中间有消息队列作为缓冲，因此服务间可以完全解耦，生产者发送请求的时候，不必要求消费者必须在线，等到消费者上线完成消费后再给生产者响应。

消息队列还有其他一些复杂的应用场景，但本质上还是属于这三种模式的范畴。

# 消息队列关注的功能

上面提到的异步、解耦和削峰三个作用是站在系统层面的抽象描述，当我们真正需要设计一个消息队列时，需要考虑哪些功能？

