---
layout: distill
title:  快照隔离
date:   2023-03-06 10:45:16 +8:00
description: 快照隔离于可串行化
tags: 数据库 事务 快照隔离
categories: Databases
giscus_comments: true

toc:
  - name: 什么是快照隔离
    subsections:
      - name: 实现
      - name: 观察一致性快照的可见性规则
---

# 什么是快照隔离

快照隔离（Snapshot isolation），指的是每次事务启动时，数据库就为这个事务提供一个当前数据库的一致性快照（数据库中所有已提交的记录），后续其他事务对数据的增删改操作，这个事务都看不到，它始终看到的是自己的一致性快照。

## 实现

快照隔离需要使用长写锁来防止脏写。（参阅[[2023-03-03-database-transactions]]）。因此意味着进行写入的事务会阻止其他事务修改相同的对象。但读取则不需要加锁，从性能的角度来看，快照隔离的关键原则是：**读不阻塞写，写不阻塞读**。

为了实现快照隔离，数据库需要保留一个对象的多个不同提交版本，因为各种正在进行的事务可能需要看到数据库在不同时间点的状态。因为数据库同时维护耽搁对象的多个版本，所以这种技术被称为**多版本并发控制（MVCC, Multi-version concurrency control）**。

{% include figure.html path="assets/img/fig7-7.png" class="img-fluid rounded z-depth-1" zoomable=true %}

上图说明了 PostgreSQL 如何实现 MVCC 的快照隔离（其他实现类似）。当一个事务开始时，它被赋予一个唯一的，永远增长的事务ID（`txid`）。每当事务向数据库写入任何内容时，它所写入的数据都会被标记上写入者的事务ID。

> 事务ID是一个32位的整数，所以大约会在40亿次事务后溢出。PostgreSQL 的 Vacuum 过程会清理老旧的事务ID，确保事务ID溢出（回卷）不会影响到数据。

表中的每一行都有一个 `created_by` 字段，其中包含将改行插入到表中的事务ID。此外，每行都有一个 `deleted_by` 字段，保存删除该记录的事务ID。在稍后的时间，当确定没有事务可以再访问到被删除的数据时，数据库的垃圾收集过程会将所有带有删除标记的行移除，并释放空间。

`UPDATE` 操作在内部翻译为 `DELETE` 和 `INSERT` 。例如在事务13从账户2中扣除 100 美元，将余额从500美元改为400美元。实际上包含两条账户2的记录：余额为$500的行被标记为*被事务13删除*，余额为 $400的行*由事务13创建* 。

## 观察一致性快照的可见性规则

当一个事务从数据库中读取时，事务ID可以决定该事务能看到哪些对象，看不到哪些对象。具体的规则如下：

1. 在每次事务开始时，数据库列出当时所有其他*尚未提交或尚未终止*的事务，后面即使这些事务已提交，执行的任何写入当前事务都会忽略掉；
2. 被终止事务所执行的任何写入都会被忽略；
3. 具有较晚事务ID（即当前事务之后开始的事务）的事务所做的任何写入都会被忽略，不管这些事务是否已提交；
4. 所有其他写入，对应用都是可见的；

换句话说，如果一下两个条件都成立，则对象对事务可见：

* 读事务开始时，创建该对象的事务已经提交；
* 对象未被标记为删除；或者如果对象被标记为删除，但请求删除的事务在读事务开始时还未提交；


